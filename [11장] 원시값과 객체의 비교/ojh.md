- 🌟🌟🌟원시 타입과 객체(참조) 타입 차이 3가지 (정말 기본적이지만 중요한 부분)
  - 원시 타입: **변경 불가능** vs 객체 타입: **변경 가능**
  - 원시 타입: 원시 값을 변수에 할당하면 변수에는 **실제 값**이 저장된다. vs 객체 타입: 객체를 변수에 할당하면 변수에는 **참조 값**이 저장된다.
  - 원시 타입: 원시 값을 가진 변수를 다른 변수에 할당하면 원시 값이 복사되어 전달된다. (**값에 의한 전달 pass by value**) vs 객체 타입: 객체를 가르키는 변수를 다른 변수에 할당하면 참조 값이 복사되어 전달된다. **(참조에 의한 전달 pass by Reference)**

# 11.1 원시 값

---

1. **변경 불가능한 값**
   - 원시 값은 변경 불가능한 값 → 이 말은 원시 값 자체를 바꿀 수 없다는 의미로 변수에는 재할당을 통해 변수 값을 변경할 수 있음.
   - 상수는 재할당이 불가능한 변수 ← 변경 불가능한 값과 헷갈리지 X
   - 데이터의 신뢰성을 보장한다.
   - 원시 값을 재할당하면 메모리 공간에 저장된 원시 값을 변경하는 것이 아니라 메모리 공간을 확보하고 재할당한 원시 값을 저장한 후 변수가 이를 가르키는 것 뿐임. → 🌟❗ 즉 변수가 참조하던 메모리 공간의 주소가 바뀐다.
   - 불변성!!
   - 🤔 만약 재할당 외에 원시값인 변수 값을 변경할 수 있다면 예기치 않게 변수 값이 변경될 수 있다는 것을 의미하며, 이는 값의 변경 상태 변경을 추적하기 어려워진다.
2. **문자열과 불변성**

   - 문자열 2바이트. 원시값을 저장하기 위해서는 먼저 확보해야 하는 메모리 공간의 크기를 정해야 한다.
   - 문자열의 경우에는 몇 개의 문자열로 이루어졌느냐에 따라 필요한 메모리 공간의 크기가 결정된다. 예시 ) Hello → 5개의 문자열 10 바이트 ↔ 숫자는 값에 상관없이 동일하게 8 바이트
   - C 언어는 char 타입과 이의 배열로 문자열을 나타내고, Java 는 String 객체를 써서 문자열을 나타낸다.
   - 하지만 자바스크립트에서 문자열은 원시값이며, 변경 불가능하다!!
   - 문자열은 **유사객체배열**이기 때문에 각 문자에 접근 가능
     - 유사객체배열: 배열처럼 index 로 프로퍼티 값에 접근할 수 있고 length 프로퍼티를 갖는 객체를 의미함. index 를 통해 각 문자 접근도 for 문도 가능.

   ```jsx
   var str = "string";

   str[0] = "S";

   console.log(str); // 그래도 string
   ```

   - 접근은 가능하지만 변경은 할 수 없다. → 데이터의 신뢰성 보장!!

3. **값에 의한 전달**
   - 변수에 변수를 할당할 때 새로운 원시 값이 생성되어 해당 변수에 할당된다. 즉, 할당 받는 변수에는 할당되는 변수의 원시값이 복사되어 전달된다. → 값에 의한 전달. ❗**다른 메모리 공간**
   - 책의 그림에서는 변수에 원시 값을 갖는 변수를 할당하면 복사되는 것으로 표현했지만, 실제 동작에는 차이가 있을 수 있다. ⚠️ 참고로, 파이썬의 경우에는 할당하는 시점에는 같은 값을 참조하다가 재할당이 이루어지는 순간 새로운 메모리 공간에 재할당 될수도 있다.
   - 값에 의한 전달이라고 사용하지만, 엄격하게 표현하면 **변수에는 메모리 주소가 전달**되는 것임. (공유에 의한 전달?)
   - 메모리 주소를 통해 메모리 공간의 접근하면 값을 알 수 있는 것임.
   - 결국 두 변수의 원시 값은 서로 다른 메모리 공간에 저장된 별개의 값이 되어 어느 한쪽에서 값이 변경되더라도 간섭할 수 없다!!!

# 11.2 객체

---

- 객체는 프로퍼티 개수가 정해져 있지 않고 동적으로 추가 삭제가 될 수 있다. 값에도 제약이 없기 때문에 객체는 원시 값과 같이 확보해야 할 메모리 공간을 사전에 정해 둘 수 없다.
- ❗객체를 생성하고 프로퍼티에 접근하는 것도 원시 값과 비교할 때 비용이 많이 드는 일이다.
- 🌟🌟 자바스크립트의 객체 관리 방식
  - 자바스크립트 객체는 프로퍼티 키를 인덱스로 사용하는 해시 테이블이라고 한다.
  - 대부분의 자바스크립트 엔진은 해시 테이블과 유사하지만 높은 성능을 위해 해시 테이블보다 나은 방식으로 객체를 구현한다.
  - 자바나 C++ 같은 클래스 기반 객체지향 언어는 사전에 정의된 클래스를 기반으로 객체를 생성한다. 즉, 프로퍼티와 메서드가 정해져 있고 그대로 생성한다. ↔ 자바스크립트는 클래스 없이 생성 가능하고 동적으로 프로퍼티와 메서드를 추가할 수 있는 편리함이 있지만, 생성과 프로퍼티 접근에 비용이 많이 드는 비효율적인 방식이다!
  - V8 자바스크립트 엔진에서는 프로퍼티에 접근하기 위해 동적 탐색 대신 히든 클래스 방식으로 사용해 C++ 객체의 프로퍼티 접근 정도의 성능은 보여준다. ← 히든 클래스는 자바와 같이 고정된 객체 레이아웃(클래스)와 유사하게 동작한다.
  - 🌟🌟🌟 **내가 이해한 히든 클래스와 인라인 캐싱**
    자바스크립트 객체는 해시 테이블 형태로 프로퍼티나 메서드를 저장하고 있다. 하지만 여기에는 문제점이 존재하는데, 자바 혹은 C++ 처럼 클래스 기반으로 생성된 객체에 비해 프로퍼티에 접근하는 속도가 느리다는 것이다. 해시 테이블 형태이기 때문에 그냥 원시 값 찾는 것처럼 빠르게 찾을 수가 없음 (⚠️GPT 말로는 속도 말고도 Cashe 비효율성도 존재한다고 함. 연속된 메모리 공간을 사용하지 않기 때문에)
    → 이를 보완하기 위해 나온것이 자바스크립트 **V8 엔진의 히든 클래스**이다. **히든 클래스는 객체의 프로퍼티에 대한 오프셋을 가지고 있고, 동적으로 변동이 생길 때마다 새로운 히든 클래스를 만들어 참조하게 만드는 것이다.** → 이를 통해 기존 프로퍼티에 접근하는 것보다 빠르게 접근할 수 있게 된다.
    ```jsx
    var obj = {}; // C0 참조 / x를 추가 참조하면 C1 히든 클래스가 된다는 정보 포함
    obj.x = 1; // C1 참조 / y를 추가 참조하면 C1 히든 클래스가 된다는 정보 포함
    obj.y = 1; // C2 참조
    ```
    ### 다만 히든 클래스가 문제가 없는 것은 아니다!
    ## 🔥 히든 클래스의 문제점 (잘못 사용할 경우)
    히든 클래스가 항상 좋은 것은 아니고, 잘못 사용할 경우 오히려 성능이 저하될 수도 있어요.
    ### 🚨 1. **동적 프로퍼티 추가 문제**
    ```jsx
    var obj = { x: 1, y: 2 };
    obj.z = 3; // ❌ 기존 히든 클래스를 깨고 새로운 히든 클래스가 생성됨
    ```
    - 동적으로 프로퍼티가 추가될 경우 **새로운 히든 클래스가 계속 만들어지기 때문에** 성능 저하가 발생할 수 있음.
    ### 🚨 2. **프로퍼티 추가 순서가 다를 경우**
    ```jsx
    var obj1 = {};
    obj1.x = 1;
    obj1.y = 2;

    var obj2 = {};
    obj2.y = 2; // ❌ obj1과 다른 히든 클래스를 생성
    obj2.x = 1;
    ```
    - `obj1`과 `obj2`는 동일한 프로퍼티를 가지지만, 추가 순서가 다르므로 **서로 다른 히든 클래스를 가짐**.
    - 그렇기 때문에 동일한 순서로 생성해야 함.
    ### 👍그렇기 때문에 생성 시점에 프로퍼티를 생성하는 것이 좋다.
    ### 💭그럼 inline cashing 이란?
    - 히든 클래스를 사용하는 이유는 결국 빠르게 접근하기 위해 필드의 오프셋 값이다. 즉, 인라인 캐싱이란 이 오프셋 값을 캐싱하는 것!
    ### 📝 정리
    - **히든 클래스는 객체의 필드(프로퍼티)의 메모리 위치(오프셋)를 저장하는 역할**을 함.
    - 하지만, 매번 `obj.x` 접근할 때 히든 클래스를 다시 조회하면 여전히 성능 비용이 발생할 수 있음.
    - **➡️ 그래서 V8 엔진은 이 오프셋 값을 캐싱(Inline Cache, IC)하여, 같은 구조의 객체라면 추가적인 조회 없이 빠르게 접근하도록 최적화함!** 🚀

1. **변경 가능한 값**

   - 원시값과 달리 객체는 변경 가능한 값이다.
   - 객체를 할당한 변수가 기억되는 메모리 주소를 통해 메모리 공간에 접근하면 **참조값** 에 접근할 수 있다. 참조 값은 생성된 객체가 저장된 메모리 공간의 주소, 그 자체이다.
   - 참조 값을 통해 실제 객체에 접근
   - 객체를 할당한 변수는 재할당 없이 객체를 직접 변경할 수 있다. 프로퍼티 값 갱신, 프로퍼티 동적 추가, 삭제 → 변경 가능한 값
   - 객체를 생성하는 방식은 복잡하고 비용이 많이 들기 때문에 객체를 변경할 때마다 원시 값처럼 이전 값을 복사해서 새롭게 생성하면 메모리 효율적 소비가 어렵고 성능이 나빠진다. → 따라서 메모리를 효율적으로 사용하기 위해 객체는 변경 가능한 값이다.
   - ❗ 이러한 구조적 단점의 부작용으로 여러 개의 식별자가 하나의 객체를 공유할 수 있게 된다.
   - **얕은 복사 vs 깊은 복사 (중요한 부분이긴 하죠)**

1. **참조에 의한 전달**
   - 객체를 가르키는 변수를 다른 변수에 할당하면 원본의 참조 값이 복사되어 전달된다. 이를 **참조에 의한 전달**이라 한다.
   - 이 과정으로 복사하면 같은 참조 값을 가지기 때문에 두 식별자가 하나의 객체를 공유하게 된다.
   - 🌟 값에 의한 전달과 참조에 의한 전달 모두 식별자가 기억하는 메모리 공간에 저장되어 있는 값을 복사해서 전달한다. 그 메모리 공간 안에 저장된 값이 원시값이나 참조값이냐의 차이일뿐… → 따라서 자바스크립트에는 **값에 의한 전달**만이 존재한다고 말할 수 있다.
   - 사실 자바스크립트의 이러한 동작 방식을 설명하는 정확한 용어가 존재하지는 않는다.
   - 즉, 다른 언어에서 의미하는 전달과는 의미가 일치하지 않는다.
