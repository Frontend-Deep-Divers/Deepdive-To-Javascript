- 에버그린 브라우저의 ES6 지원율은 약 98% 로 거의 대부분 ES6 사양을 지원한다.
  ![image.png](attachment:60c39ddd-3465-433b-a2de-6373c3780caf:image.png)
- 하지만 IE 11 의 ES6 지원율은 약 11%이다….
- 매년 새롭게 도입되는 **ES6 이상의 버전 (ES6+)** 과 제안 단계에 있는 **ES 제안 사양(ES.NEXT)** 은 브라우저에 따라 지원율이 제각각이다.
- 따라서 ES6+ 와 ES.NEXT의 최신 ECMAScript 사양을 사용하여 프로젝트를 진행하려면 최신 사양으로 작성된 코드를 경우에 따라 IE를 포함한 구형 브라우저에서 문제 없이 동작시키기 위한 개발 환경을 구축하는 것이 필요하다.
- 또한, 대부분의 프로젝트가 모듈을 사용하므로 모듈 로더도 필요하다. ES6 모듈은 대부분의 모던 브라우저에서 사용할 수 있지만 아직 ESM 보다는 별도의 모듈 로더를 사용하는 것이 일반적이다.
  ![image.png](attachment:aa4ada37-85fd-49c6-945e-87b806c90b7f:image.png)
- 트랜스파일러인 Bebel 과 모듈 번들러인 Webpack ES6+/ES.NEXT 개발 환경을 구축해 보자.
  ![image.png](attachment:5743af48-7218-4711-ab79-4da96c8a4ec1:image.png)

# 49.1 Babel

---

- 다음 예제에서는 ES6의 화살표 함수가 ES7의 지수 연산자를 사용한다.
  ![image.png](attachment:ad0dcffb-0800-4ca6-85c9-9147ec161593:image.png)

### 여기서부터 실습

### 이건 브라우저가 뭘 쓸까요? 에 대한 답

좋은 질문입니다. 결론부터 말하자면 **“브라우저는 무조건 ESM만 지원하는 건 아니고, 기본은 전통적인 스크립트 방식(CJS도 아님)이며, ESM은 명시적으로 설정해야 작동합니다.”**

---

## ✅ 정리하면

| 구분                              | 브라우저의 기본 스크립트 방식                | ESM 지원 방식                              |
| --------------------------------- | -------------------------------------------- | ------------------------------------------ |
| 기본                              | **전통적인 `<script>` 방식 (글로벌 스코프)** | `<script type="module">`으로 명시해야 동작 |
| CJS (`require`, `module.exports`) | ❌ 브라우저는 애초에 지원 안 함              | ❌ Node.js 전용                            |
| ESM (`import`, `export`)          | ❌ 기본 `<script>`로는 안 됨                 | ✅ `type="module"` 필요                    |

---

## 🔍 왜 브라우저는 CJS를 지원하지 않나?

- CJS는 `require()` 기반으로 **동기적**으로 모듈을 불러옵니다.
- 브라우저 환경은 네트워크 요청이 필요한데, **동기적으로 로드하면 UI가 멈추기 때문**에 부적절합니다.
- 그래서 브라우저는 `require`가 아예 존재하지 않습니다.

---

## ✅ 브라우저에서 ESM 사용하는 방법

```html
html 복사편집
<!-- ✅ 브라우저가 ESM 모듈로 인식하려면 반드시 type="module" -->
<script type="module" src="./dist/main.js"></script>
```

- 이때는 `import` 문을 사용할 수 있고,
- 모듈 스코프이기 때문에 전역 오염도 없습니다.
- `defer`가 자동 적용되고, top-level await도 허용됩니다.

---

## ✅ 결론

- 브라우저의 **기본은 ESM이 아닙니다.**
- `<script type="module">`로 명시한 경우에만 ESM으로 인식하고, 이때 `import`와 `export`가 작동합니다.
- **CJS (`require`)는 애초에 브라우저 환경에서 사용할 수 없습니다.**

- 아니 브라우저에서 require 을 못쓰네!!!
- 자 그럼 이제 Webpack 을 써보자

# 49.2 Webpack

---

- Webpack 은 의존 관계에 있는 자바스크립트, CSS, 이미지 등의 리소스들을 하나의 파일로 번들링하는 모듈 번들러이다.
- Webpack 을 사용하면 의존 모듈이 하나의 파일로 번들링 되므로 별도의 모듈 로더가 필요 없다!
- 그리고 여러 개의 자바스크립트 파일을 하나로 번들링하므로 HTML 파일에서 script 태그로 여러 개의 자바스크립트를 로드해야 하는 번거로움도 사라진다.

- 번들링 하기 전에 Babel 로 트랜스 파일링 할거지롱.

![image.png](attachment:c3d59435-7a2f-4a26-8567-2546e78d15cb:image.png)

- Bable 을 사용하여 ES6+/ES.NEXT 사양의 소스코드를 ES5 사양의 소스코드로 트랜스파일링해도 브라우저가 지원하지 않는 코드가 남아 있을 수 있다.
- ES6 의 Promise, Object.assgin, Array.from 등은 ES5 사양으로 트랜스파일링해도 ES5 에서 대체 기능이 없기 때문에 그대로 남는다.
- 일단 어떻게 되는지 봐보자.

- 🌟**@babel-polyfill은 개발 환경에서만 사용하는 것이 아니라 실제 운영 환경에서도 사용해야 하기 때문에 개발 의존성으로 설치하는 —save-dev 옵션을 사용하지 않는다.**
