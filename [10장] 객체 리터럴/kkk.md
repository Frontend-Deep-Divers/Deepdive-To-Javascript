# 🌻 MP : 프로토타입 객체지향 언어인 자바스크립트

## 🔥 **핵심 차이점**

1️⃣ **클래스 기반 객체지향 언어 (Java, C++)**

- 클래스를 먼저 정의하고, 해당 클래스를 기반으로 인스턴스를 생성
- 객체(인스턴스)는 클래스에서 정의된 구조를 따른다.
- **클래스가 객체 생성을 주도**하고, 상속은 클래스 단위로 이루어진다.

2️⃣ **프로토타입 기반 객체지향 언어 (JavaScript)**

- **객체가 곧 객체를 상속한다.** (클래스 없이도 상속 가능)
- **`Object.create(proto)`**, 생성자 함수, 클래스(**`class`**) 등 다양한 방식으로 객체를 만들 수 있지만,**결국 모든 객체는 프로토타입 체인을 통해 상속**된다.
- 상속 구조를 직접 컨트롤할 수 있으며, 기존 객체를 기반으로 새로운 객체를 만들 수 있다.
    - 다른 언어도 그렇지 않나요?
    - 

> ✅ **즉, 자바스크립트에서 객체는 "클래스가 아니라 다른 객체를 기반으로 생성"되며,모든 객체는 프로토타입 체인을 따라 속성과 메서드를 상속받는다는 점이 가장 큰 차이점이야!** 🚀
> 

## 자바스크립트에서도 클래스 기반으로 객체 생성이 가능합니다. 이 경우에도 다른 언어와 다르게 동작하나요?

### **📌 자바스크립트의 클래스(`class`)는 결국 프로토타입 기반!**

자바스크립트에서도 **`class`** 문법을 사용해서 객체를 생성할 수 있지만,

🚨 **자바스크립트의 클래스도 결국 "프로토타입 기반"으로 동작합니다.** 🚨

즉, **문법적으로는 "클래스 기반 객체 생성"처럼 보이지만, 내부적으로는 여전히 프로토타입을 사용해서 동작하는 것**이 가장 큰 차이입니다.

다른 클래스 기반 언어(Java, C++ 등)처럼 **완전히 독립적인 클래스 구조가 아니라, 결국 프로토타입을 통해 상속**이 이루어진다는 거지!

---

### **📌 자바스크립트 `class`의 동작 방식**

```jsx
class Person {
  constructor(name) {
    this.name = name;
  }
  greet() {
    console.log(`Hello, I'm ${this.name}`);
  }
}

const person1 = new Person("홍길동");

console.log(person1.__proto__ === Person.prototype);  // ✅ true
console.log(Person.prototype.__proto__ === Object.prototype);  // ✅ true
```

✅ **클래스를 사용했지만, 결국 `__proto__`를 통해 프로토타입 체인이 연결됨**

✅ **즉, `class` 문법은 생성자 함수와 `prototype`을 감싼 "문법적 편의성"일 뿐, 본질적으로 프로토타입 기반**

### 🚀 결론

**자바스크립트에서 `class`를 사용해도, 결국 객체는 프로토타입을 통해 동작한다.**

✅ 다른 언어처럼 완전히 독립적인 클래스 개념이 아니라, "프로토타입을 감싼 문법적 설탕(Syntactic Sugar)"일 뿐!

## 그렇다면 왜 이 방법을 사용하나요? 이 방법의 장점이 무엇인가요?

자바스크립트의 프로토타입 기반 상속 방식이 **다른 언어와 다른 점**은,

✔ **개발자가 프로토타입을 직접 컨트롤할 수 있다는 점**

✔ **클래스를 미리 선언하지 않아도 객체를 생성하고, 상속을 쉽게 구현할 수 있다는 점**

다른 객체지향 언어(Java, C++ 등)에서도 **상속을 통해 기존 객체(클래스)를 기반으로 새로운 객체를 만들 수 있지만**,

📌 **자바스크립트는 클래스 없이도 `Object.create(proto)` 같은 방식으로 프로토타입을 직접 지정할 수 있다는 것이 가장 큰 차이!**

### **자바스크립트의 프로토타입 기반 상속의 핵심 장점**

1️⃣ **클래스 없이도 객체를 만들고 상속할 수 있다.**

- **`Object.create(proto)`**를 이용해 기존 객체를 기반으로 새로운 객체를 쉽게 생성 가능
- 즉, **객체가 곧 객체를 상속할 수 있는 구조**

2️⃣ **프로토타입을 개발자가 직접 변경할 수 있다.**

- **`Object.setPrototypeOf(obj, newProto)`**를 사용해 동적으로 프로토타입 변경 가능
- 런타임에서도 객체의 동작을 수정할 수 있음

3️⃣ **더 유연한 상속 구조를 만들 수 있다.**

- 다중 상속이 불가능한 클래스 기반 언어와 달리,자바스크립트에서는 프로토타입 체인을 활용해 여러 객체를 조합하여 상속 가능

---

🪽

## 10.1 객체란?

객체는 **프로퍼티**와 **메서드**로 구성된 집합체입니다.

> 프로퍼티는 객체의 상태를 나타내는 값이며, 메서드는 프로퍼티를 참조하고 조작할 수 있는 동작(함수)입니다.
> 

특징:

- 자바스크립트에서 함수도 객체로 취급됨
- 객체는 상태(프로퍼티)와 동작(메서드)의 조합
- 데이터를 구조화하기에 용이함

## 10.2 객체 리터럴에 의한 객체 생성

자바스크립트는 **프로토타입 기반 객체 지향 언어**입니다.

`클래스 기반 vs 프로토타입 기반`:

```
클래스 기반: 클래스를 사전에 정의하고 필요할 때 인스턴스를 생성
프로토타입 기반: 객체의 원형(프로토타입)을 이용해 새로운 객체를 직접 생성 가능
```

### 다양한 객체 생성 방법:

1. **객체 리터럴** (유일하게 함수를 사용하지 않음)
2. Object 생성자 함수
3. 생성자 함수
4. Object.create 메서드
5. 클래스 (ES6)

### 리터럴이란?

`리터럴`은 사람이 이해할 수 있는 문자나 기호를 사용하여 값을 생성하는 표기법

```jsx
// 객체 리터럴 사용
const person = {
  name: "홍길동",
  age: 30,
  sayHello: function() {
    console.log(`안녕하세요, ${this.name}입니다.`);
  }
};
// 빈 객체 생성
const emptyObject = {};
```

**객체 리터럴 사용 이점**:

- 클래스 사전 정의가 필요 없음
- `new` 연산자 생략 가능
- 간단하고 직관적인 객체 생성 방법

## 10.3 프로퍼티

> 객체는 프로퍼티의 집합이며, 프로퍼티는 키와 값으로 구성됩니다.
> 

가능한 값의 유형:

- **프로퍼티 키**: 모든 문자열 또는 심벌
- **프로퍼티 값**: 자바스크립트에서 사용할 수 있는 모든 값

### 프로퍼티 키 네이밍 규칙:

```jsx
// 유효한 이름은 따옴표 생략 가능
const obj = {
  firstName: "홍",
  "last-name": "길동"  // 하이픈이 있어 따옴표 필요
};

// 프로퍼티 키 중복 선언 (나중에 선언한 값으로 덮어씌워짐)
const duplicateObj = {
  name: "홍길동",
  name: "김철수"  // "김철수"로 덮어씌워짐 (에러 없음)
```

## 10.4 메서드

`일급 객체`란 값처럼 취급되는 객체로:

- 변수에 할당 가능
- 함수의 매개변수로 전달 가능
- 함수의 반환값으로 사용 가능

자바스크립트에서 **함수는 일급 객체**이므로 프로퍼티 값으로 사용 가능합니다.

```jsx
const calculator = {
  result: 0,
  add: function(a, b) {
    this.result = a + b;
    return this.result;
  },
  subtract: function(a, b) {
    this.result = a - b;
    return this.result;
  }
};
// 메서드 호출
calculator.add(5, 3);  // 8
```

## 10.5 프로퍼티 접근

프로퍼티 접근 방법:

1. **마침표 표기법**(dot notation):
    
    ```jsx
    객체.프로퍼티키
    ```
    
2. **대괄호 표기법**(bracket notation):
    
    ```jsx
    객체['프로퍼티키']
    ```
    

주의사항

- 대괄호 표기법 사용 시 프로퍼티 키는 **반드시 따옴표**로 감싸야 함
    - 따옴표가 없으면 식별자(변수)로 해석됨
- 유효하지 않은 이름의 프로퍼티는 대괄호 표기법만 사용 가능

```jsx
const person = {
  name: "홍길동",
  "job-title": "개발자"
};

// 마침표 표기법
console.log(person.name);  // "홍길동"

// 대괄호 표기법
console.log(person["name"]);  // "홍길동"
console.log(person["job-title"]);  // "개발자" (하이픈이 있어 대괄호 표기법만 가능)

```

동적 프로퍼티 처리:

- 존재하지 않는 프로퍼티에 값을 할당하면 프로퍼티가 동적으로 생성됨
- 존재하지 않는 프로퍼티를 삭제해도 에러 발생하지 않음

## 10.9 ES6에서 추가된 객체 리터럴의 확장 기능

### 프로퍼티 축약 표현

변수 이름과 프로퍼티 키가 동일한 경우, 프로퍼티 키 생략 가능:

```jsx
// ES5
var x = 1, y = 2;
var obj = { x: x, y: y };

// ES6
const x = 1, y = 2;
const obj = { x, y };  // { x: 1, y: 2 }와 동일
```

### 메서드 축약 표현

`function` 키워드 생략 가능:

```jsx
// ES6
const obj = {
  // sayHello: function() {
  sayHello() {  // function 키워드 생략
    console.log('Hello!');
  }
}
```

### 계산된 프로퍼티 이름

객체 리터럴 내부에서 프로퍼티 키를 동적으로 생성 가능:

```jsx
const prefix = 'prop';
const i = 0;
const obj = {
  [`${prefix}-${i}`]: i,
  [`${prefix}-${i+1}`]: i+1
};
console.log(obj);  // { 'prop-0': 0, 'prop-1': 1 }
```