# 9.1 타입 변환이란?

- 개발자의 의도에 따라 타입을 변환하는 것을 **명시적 타입 변환, 타입 캐스팅** 이라고 한다.
- 개발자의 의도와는 상관없이 표현식을 평가하는 도중에 자바스크립트 엔진에 의해 암묵적으로 타입이 자동으로 변환되는 것을 **암묵적(묵시적) 타입 변환 또는 타입 강제 변환**이라고 한다.
- 명시적 타입 변환이나 암묵적 타입 변환이 기존 원시 값을 직접 변경하는 것은 아니다. 애초에 원시값은 변경 불가능한 값이므로 변경할 수 없다. 타입 변환이란 원시값을 사용하여 새로운 원시 값을 생성하는 것이다.
- 💭 암묵적 타입 변환으로 인해 결과를 예측하지 못하거나 일치하지 않아 오류를 발생시킬 가능성이 높아진다. 그렇다면 명시적 타입 변환만 사용하고 암묵적 타입 변환이 발생하지 않도록 코드를 작성하면 어떨까? → 때로는 명시적 타입 변환보다 암묵적 타입 변환이 가독성 측면에서 더 좋을 수도 있다. ex ) 자바스크립트 문법을 잘 이해한 개발자에게는 (10).toString() 보다 10+ 이 더욱 간결하고 이해하기 쉽다.

# 9.2 암묵적 타입 변환

1. 문자열 타입으로 변환
   - - 연산자의 피연산자 중 하나 이상이 문자열인 경우 다른 모든 피연산자를 문자열로 바꿈
   - 템플릿 리터럴 표현식은 평가 결과를 문자열로 바꿈
2. 숫자 타입으로 변환
   - 산술 연산자의 피연산자를 숫자 타입으로 만든다. 단, + 는 문자열 연결 연산자인지 잘 파악해야 한다.
   - 비교 연산자도 피연산자를 숫자 타입으로 바꾼다.
   - - 단항 연산자는 숫자타입으로 바꾼다.
   - true ⇒ 1, false, null ⇒ 0
   - ⚠️ undefined, {}. [], function() 등은 변환되지 않아 NaN 을 반환한다!
3. 불리언 타입으로 변환
   - 조건문이나 for 문과 같은 제어문, 상항 연산자의 조건식은 불리언 타입으로 변환한다.
   - 아래 조건들은 false 임
     - false
     - undefined
     - null
     - 0, -0
     - NaN
     - ‘’ (빈 문자열)

# 9.3 명시적 타입 변환

- 의도적으로 타입을 바꾸는 방법은 여러가지가 있다.
  - 표준 빌트인 생성자 함수를 new 없이 호출
  - 빌트인 메서드를 사용하는 방법
  - 암묵적 타입 변환 이용
- ✋ 여기서 잠깐! 표준 빌트인 생성자 함수란? → 자바스크립트에서 기본적으로 제공하는 함수로 객체를 생성하기 위한 함수로 new 연산자와 함께 호출할 수 있다. new 연산자를 사용하지 않고 해당 값을 감싸 타입 변환을 시켜줄 수도 있다.
- 🚧 이전에 배웠던 래퍼 객체와 살짝 혼동 될 수 있는데 개념으로 보면 빌트인 객체가 더 넓은 범위이고 래퍼 객체란 빌트인 함수를 사용하기 위해 자바스크립트 엔진이 래퍼 객체로 감싸주어 함수를 사용할 수 있게 만들어 주는 것이다. 생성된 래퍼 객체는 사용 후 다시 되돌리는 것으로 보인다.

1. 문자열 타입으로 변환

   - String 생성자 함수 사용. ex) String(1);
   - toString 사용. ex) (1).toString();
   - 문자열 연결 연산자 사용. ex) 1+””;

1. 숫자 타입으로 변환

   - Number 생성자 함수 사용.
   - parseInt(), parseFloat() 함수 사용 (문자열만 숫자 타입으로 변환 가능)
   - - 단항 연산자 사용
   - - 산술 연산자 사용. ex ) ‘0’ \* 1 ⇒ 0

1. 불리언 타입으로 변환
   - Boolean 생성자 함수 사용.
   - !! 부정 논리 연산자 2번 사용. ex ) !!0 ⇒ false, !!1 ⇒ true

# 9.4 단축 평가

1. **논리 연산자를 사용한 단축 평가**

   - 내가 그동안 개발하면서 정말 많이 사용했었던 문법들.
   - && , ||
   - && : 좌항이 true 면 우항을 실행함.
   - || : 좌항이 false 이면 우항을 실행함.

   | 단축 평가 표현식  | 평가 결과 |
   | ----------------- | --------- | -------- | -------- |
   | true              |           | anything | true     |
   | false             |           | anything | anything |
   | true && anything  | anything  |
   | false && anything | false     |

   - if 문을 대체해서 사용할 수 있음
   - 책에서는 객체와 함수에 사용할 수 있다고 나옴
   - 객체 예시

   ```jsx
   var element = null;
   var value = element && element.value; // null 이 할당.
   ```

   - 함수 예시

   ```jsx
   function getStringLength(str) {
     str = str || ""; // str 이 없을 시 기본값 설정.
     return str.length;
   }
   ```

   - 실제로 개발을 하게 되다보면 정말 많이 사용하게 된다.
   - && 연산자의 경우, API response data 가 존재하는 지 확인한 후 그 안의 요소들을 만들어 낼 때 사용한다.
   - || 연산자의 경우, 함수의 매개변수 혹은 컴포넌트의 prop 을 받을 때 기본값, 동작을 설정해주기 위해 사용한다.
   - Text 컴포넌트 예시

   ```tsx
   function Text({
     fontType,
     fontSize,
     fontColor,
     fontWeight,
     children,
     style,
     className,
   }: TextProps) {
     return (
       <p
         className={`${S.textStyle} ${className || ""}`}
         style={{
           ...style,
           fontSize: fontSize && `${fontSize}px`,
           color: fontColor && defaultTheme.colors[fontColor],
           fontWeight: fontWeight && defaultTheme.fontWeight[fontWeight],
         }}
         data-fonttype={fontType}
       >
         {children}
       </p>
     );
   }

   export default Text;
   ```

1. **옵셔널 체이닝 연산자 ( ?. )**

   - **ES11(2020 버전) 에 도입됨.**
   - 좌항의 피연산자가 null 또는 undefined 인 경우 undefined를 반환하고 그렇지 않으면 우항의 프로퍼티 참조를 이어나간다.
   - ?. 옵셔널 체이닝 연산자가 도입되기 이전에는 논리 연산자 && 를 사용하여 단축평가를 하여 null 과 undefined 를 판단하였다. → 💥 이렇게 하는 경우 좌항이 false 로 평가되는 값 (0, ‘’,NaN) 등인 경우 좌항을 그대로 반환하게 된다
   - 옵셔널 체이닝을 사용하는 경우 null 이나 undefined 가 아닌 이상 우항을 프로퍼티 참조를 이어나간다.

   ```jsx
   var str = "";
   var length1 = str && str.length;
   var length2 = str?.length;
   console.log(length1, length2); // ''. 0
   ```

1. **null 병합 연산자 ( ?? )**

   - **ES11(2020 버전) 에 도입됨.**
   - 좌항의 피연산자가 null 또는 undefined 인 경우 우항의 피연산자를 반환하고 그렇지 않은 경우 좌항의 피연산자를 반환한다. → 변수에 기본값 설정할 때 유용한다.
   - 위의 옵셔널 체이닝과 유사하게 만약 false 로 판단되는 값이 좌항에 위치하게 되면 0, ‘’ 와 같은 값이 기본값으로 유효하더라도 무시되어 예기치 않은 동작이 발생할 수 있게 된다.
   - null 병합 연산자 ?? 를 사용하게 되면 false 로 판단되는 값이더라도 null 이나 undefined 가 아닌 이상 그대로 반환한다.

   ```jsx
   var foo1 = "" || "default value";
   var foo2 = "" ?? "default value";

   console.log(foo1, foo2); // '' , default value
   ```

### 💡 결론 : 논리 연산자를 통해 단축 평가가 일어날 때, false 로 판단되는 값이 좌항에 있는 경우 예상치 못한 문제가 발생할 수 있다. 이를 막기 위해 ES11 버전에서 옵셔널 체이닝과 null 병합 연산자가 도입된 것으로 보인다.

### 물론 그래도 논리 연산자를 사용하여 단축 평가를 시켜야 하는 경우는 필요할 것으로 생각이 된다.
