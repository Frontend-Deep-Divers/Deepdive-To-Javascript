# 13. 스코프

## 13.1 스코프란?

- **스코프(Scope)**: 자바스크립트 엔진이 변수를 찾을 때 사용하는 규칙.
- 스코프를 통해 같은 이름의 변수를 다른 범위에서 사용할 수 있음.
- 변수를 찾을 때 실행 문맥(context)을 고려하여 결정됨.

## 13.2 스코프의 종류

- **전역 스코프(Global Scope)**: 코드 어디에서든 접근 가능.
- **지역(함수) 스코프(Local Scope)**: 특정 함수 내부에서만 접근 가능.
- **`블록 레벨 스코프`(Block-level Scope)** (`let`, `const` 한정): 특정 블록 `{}` 내부에서만 유효.

<aside>
🍊

## 블록 레벨 스코프가 뭔가요?

중괄호로 감싸진 코드 블록 내부에서만 스코프가 유효하다. 

let, const가 블록 레벨 스코프를 가진다. 즉 이건 중괄호 내에서 = 코드 블록에서 선언되면 외부에서는 유효하지 않다!

반면, var은 블록 레벨 스코프를 따르지 않는다. 함수 레벨 스코프를 따른다!

</aside>

## 13.3 스코프 체인

- 함수 내부에서 변수를 찾을 때, **해당 스코프 → 상위 스코프 → 전역 스코프** 순서로 탐색. (최상위 스코프가 전역 스코프)
- 하위 스코프에서 선언된 변수는 상위 스코프에서 접근 불가능.

```jsx
var x = "global";
function outer() {
  var x = "outer";
  function inner() {
    var x = "inner";
    console.log(x); // inner (가장 가까운 x를 참조)
  }
  inner();
  console.log(x); // outer
}
outer();
console.log(x); // global
```

### 13.3.1 스코프 체인에 의한 변수 검색

자바스크립트 엔진은 **`스코프 체인`**을 따라 변수를 참조하는 코드의 스코프에서 시작하여 상위 스코프 방향으로 이동하며 선언된 변수를 검색한다. 

> 절대 하위 스코프로 내려가면서 식별자를 검색하는 일은 없다.
> 

```jsx
var a = 1;
function outer() {
  var b = 2;
  function inner() {
    var c = 3;
    console.log(a, b, c); // 1 2 3
  }
  inner();
}
outer();

```

### 13.3.2 스코프 체인에 의한 함수 검색

- 스코프 체인은 변수뿐만 아니라 함수도 검색할 수 있다.
- 함수 선언문은 해당 스코프에서 최상위에 등록된다. (함수선언문은 선언 전에도 호출 가능하다 기억하는가 또 호이스팅…함수 호이스팅….)

```jsx
console.log(foo()); // "Hello from foo"
console.log(bar);   // undefined
// console.log(bar()); // TypeError: bar is not a function

function foo() {
  return "Hello from foo";
}

var bar = function() {
  return "Hello from bar";
};

console.log(bar()); // "Hello from bar"
```

## 13.4 함수 레벨 스코프

C나 자바 등을 비롯한 대부분의 프로그래밍 언어는 함수 몸체뿐만 아니라 모든 코드 블록(`if`, `for`, `while`, `try/catch` 등)이 지역 스코프를 만든다. 이를 **`블록 레벨 스코프(block level scope)`** 라 한다. 

하지만 `var` 키워드로 선언된 변수는 오로지 **함수의 코드 블록(함수 몸체)만을 지역 스코프로 인정**한다. 

이를 **함수 레벨 스코프(function level scope)** 라 한다.

```jsx
var x = 1;
if (true) {
  var x = 10; // 함수 레벨 스코프이므로 전역 변수로 취급됨
}
console.log(x); // 10
```

```jsx
var i = 10;
for (var i = 0; i < 5; i++) {
  console.log(i); // 0 1 2 3 4
}
console.log(i); // 5 (의도치 않게 변경됨)
```

`var` 키워드로 선언된 변수는 오로지 함수의 코드 블록만을 지역 스코프로 인정하지만, ES6에서 도입된 `let`, `const` 키워드는 블록 레벨 스코프를 지원한다.

```jsx
let y = 1;
if (true) {
  let y = 10; // 블록 내부에서만 유효
  console.log(y); // 10
}
console.log(y); // 1

```

## 13.5 렉시컬 스코프

<aside>
🍊

### **함수의 상위 스코프 결정 방식**

프로그래밍 언어는 함수의 **상위 스코프**를 결정하는 방식에 따라 두 가지 패턴이 존재한다.

1. **동적 스코프 (Dynamic Scope)**
    - `함수를 **어디서 호출`했는지**에 따라 상위 스코프를 결정.
    - 실행 중에 상위 스코프가 결정되므로 **동적**이다.
2. **정적(렉시컬) 스코프 (Lexical Scope)**
    - `함수를 **어디서 정의`했는지**에 따라 상위 스코프를 결정.
    - 함수 정의가 평가되는 시점에 상위 스코프가 결정되므로 **정적**이다.

대부분의 프로그래밍 언어(예: **JavaScript**)는 **렉시컬 스코프**를 따른다.

즉, **함수를 호출한 위치가 아니라, 정의된 위치에 따라** 상위 스코프가 결정된다.

</aside>

- **렉시컬 스코프(Lexical Scope)** 또는 **정적 스코프(Static Scope)**
- 자바스크립트는 렉시컬 스코프를 따름 → **함수의 선언 위치에 따라 스코프가 결정됨**

```jsx
var x = 1;
function foo() {
  var x = 10;
  bar();
}
function bar() {
  console.log(x);
}
foo(); // 1 (bar의 상위 스코프는 전역이므로 x는 1)
bar(); // 1 전역'이' 상위 스코프 (어디서 정의했는가?)
```

+.추가 만약 같은 예제가 동적 스코프라면?

```jsx
var x = 1;

function foo() {
  var x = 10;
  bar();
}

function bar() {
  console.log(x);
}

foo(); // 10, 푸'에서' 바를 호출하므로 x는 10이다.
bar(); // 1, 전역'에서' 호출 (위치를 본다)
```

## 13.6 정리

- **스코프는 변수의 유효 범위를 결정하는 규칙.**
- **자바스크립트는 기본적으로 함수 레벨 스코프(`var`)를 가지지만, `let`과 `const`는 블록 레벨 스코프를 적용.**
- **스코프 체인을 통해 변수를 탐색하며, 하위 스코프에서 선언된 변수는 상위 스코프에서 접근 불가능.**
- **자바스크립트는 렉시컬 스코프를 따르며, 함수 선언 위치에 따라 스코프가 결정됨.**