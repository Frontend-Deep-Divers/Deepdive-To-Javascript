# 15장 let, const 키워드와 블록 레벨 스코프

## 15.1 var 키워드로 선언한 변수의 문제점

1. 변수의 중복 선언이 가능하다.

```js
var x = 1;
var y = 1;

var x = 10; // 초기화문이 있는 변수 선언문은 var 키워드가 없는 것처럼 동작
var y; // 초기화문이 없는 변수 선언문은 무시
```

2. 함수 레벨 스코프를 가진다.

`if` 문이나 `for` 문에서의 `var` 변수는 전역 변수가 된다.

3. 변수 호이스팅이 발생한다.

변수 선언문 이전에 변수를 참조할 수 있게 되어 프로그램의 흐름 상 맞지 않고 가독성을 떨어뜨리며 오류를 발생시킬 여지를 만든다.

## 15.2 let 키워드

ES6에서 추가되었다.

1. 변수의 중복 선언이 불가능하다.

2. 블록 레벨 스코프를 가진다.

```js
{
  let foo = 1;
}
console.log(foo); // ReferenceError: foo is not defined
```

모든 코드 블록을 지역 스코프로 인정한다.

3. 변수 호이스팅이 발생하지 않는 **것처럼** 동작한다.

💡**let 변수는 선언 단계와 초기화 단계가 분리되어 진행된다.** 만약 초기화 단계 실행 전에 변수에 접근하려고 하면 참조 에러가 발생한다.

**스코프의 시작 지점부터 변수 초기화 사이의 참조 불가능한 구간을 일시적 사각지대(Temporal Dead Zone, TDZ)라고 부른다**.

**호이스팅이 발생하지 않는 것이 아니다**. 발생하지 않는 것처럼 동작하는 것이다.

```js
let foo = 1;

{
  console.log(foo); // ReferenceErro: Cannot access 'foo' before initialization
  let foo = 2;
}
```

변수 호이스팅이 발생하기 떄문에 참조 에러가 발생하는 모습이다.

자바스크립트는 모든 선언을 호이스팅한다. 단 `let`, `const`, `class`는 호이스팅이 발생하지 않는 것처럼 동작한다.

또, `var`와 다르게 `let` 키워드로 선언한 전역 변수는 전역 객체의 프로퍼티가 아니다. 전역 객체로 접근할 수 없다(`window.foo`). `let` 전역 변수는 전역 렉시컬 환경의 선언적 환경 레코드에 존재하게 된다.

## 15.3 const 키워드

상수(재할당이 금지된 변수)를 선언하기 위한 키워드다.

`let` 키워드와 거의 비슷한 특징을 갖는다.

`let`과의 차이점은 뭘까?

1. **`const` 키워드로 선언한 변수는 반드시 선언과 동시에 초기화해야 한다.** 그렇지 않으면 에러가 발생한다.

2. 재할당할 수없다.

`const` 키워드의 객체는 재할당이 가능하다. 객체 내부의 값을 변경하는 것도 가능하다.

`const` 키워드는 재할당을 금지할 뿐 **불변을 의미하지는 않는다**.

## 15.4 var vs. let vs. const

- ES6를 사용한다면 `var`는 사용하지 않는다.
- 재할당할 경우에만 `let`을 사용하며, 변수의 스코프를 최대한 좁게 만든다.
- 이외의 경우에는 모두 `const`를 사용해서 변수를 선언한다.
