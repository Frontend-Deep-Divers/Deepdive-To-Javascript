# 21장 빌트인 객체

## 21.1 자바스크립트 객체의 분류

자바스크립트 객체는 다음과 같이 크게 3개로 분류할 수 있다.

- 표준 빌트인 객체
  - ECMAScript 사양에 정의된 객체이다.
  - 애플리케이션 전역의 공통 기능을 제공한다.
  - 브라우저나 Node.js 환경이나 동일하게 사용 가능하다.
  - 전역 객체의 프로퍼티로 제공된다. (별도의 선언 없이 전역 변수처럼 참조할 수 있다.)
- 호스트 객체
  - ECMAScript 사양에 정의되어 있지 않은, 브라우저나 Node.js 환경에서 추가로 제공하는 객체다.
  - 브라우저 환경에서는 Web API, Node.js에서는 고유의 API에 해당한다.
- 사용자 정의 객체

## 21.2 표준 빌트인 객체

자바스크립트는 `Object`, `String`, `Number`, `Boolean`, `Symbol`, `Date` 등 40여 개의 표준 빌트인 객체를 제공한다.

`Math`, `Refelct`, `JSON`을 제외한 표준 빌트인 객체는 모두 인스턴스를 생성할 수 있는 생성자 함수 객체다. 이들은 프로포타입 메서드와 정적 메서드를 제공하지만, 아닌 객체들은 정적 메서드만 제공한다.

생성자 함수인 표준 빌트인 객체가 생성한 인스턴스의 프로토타입은 표준 빌트인 객체의 `prototype` 프로퍼티에 바인딩된 객체다.

```js
// String 생성자 함수에 의한 String 객체 생성
const strObj = new String("Lee"); // String {"Lee"}

// String 생성자 함수를 통해 생성한 strObj 객체의 프로토타입은 String.prototype이다.
console.log(Object.getPrototypeOf(strObj) === String.prototype); // true
```

이들은 인스턴스 없이도 호출 가능한 빌트인 정적 메서드를 제공한다. 또한 다양한 기능의 빌트인 프로토타입 메서드를 제공해준다.

```js
const num = new Number(1.5);

// 프로토타입 메서드
console.log(num.toFixed()); // 2

// 정적 메서드
console.log(Number.isInteger(0.5)); // false
```

## 21.3 원시값과 래퍼 객체

원시값이 존재하는데도 표준 빌트인 생성자 함수가 존재하는 이유는, 자바스크립트가 원시값을 객체처럼 사용할 수 있게끔 암묵적으로 동작하기 때문이다.

```js
const str = "Hi";

// 원시 타입이 프로퍼티와 메서드를 가진 객체처럼 동작한다.
console.log(str.length); // 2
```

원시값을 객체처럼 사용하면 자바스크립트 엔진은 암묵적으로 연관된 객체를 생성하여 생성된 프로퍼티에 접근하거나 메서드를 호출하고 다시 원시값으로 되돌린다.

**객체처럼 접근할 때 생성되는 임시 객체를 래퍼 객체(wrapper object)**라고 한다.

예를 들어 문자열에 대해 마침표 표기법으로 접근 시 그 순간 래퍼 객체인 `String` 생성자 함수의 인스턴스가 생성, 문자열은 래퍼 객체의 `[[StringData]]` 내부 슬롯에 할당된다.

```js
const str = "hi";

// 원시 타입인 문자열이 래퍼 객체인 String 인스턴스로 변환된다.
console.log(str.length); // 2
console.log(str.toUpperCase()); // HI

// 래퍼 객체로 프로퍼티에 접근하거나 메서드를 호출한 후, 다시 원시값으로 되돌린다.
console.log(typeof str); // string
```

래퍼 객체를 사용하고 난 다음, 생성된 래퍼 객체는 가비지 컬렉션의 대상이 된다.

ES6에서 추가된 원시값 심벌도 래퍼 객체를 생성한다. 리터럴 표기법으로 생성할 수 없고 `Symbol` 함수를 통해 생성해야 하므로 다른 원시값과 차이가 있다. (추후 심벌 챕터에서 살펴보자.)

원시값 `null`, `undefined`는 래퍼 객체를 생성하지 않는다. 따라서 객체처럼 사용하면 에러가 발생한다.

## 21.4 전역 객체

코드가 실행되기 전 이전 단계에 자바스크립트 엔진에 의해 생성되는, 어떤 객체에도 속하지 않은 최상위 객체다.

브라우저 환경에서는 `window`, Node.js 환경에서는 `global`이 이를 가리키는 객체였으나, ES11 이후로 `globalThis`라는 식별자로 통일되었다.

```js
// 브라우저 환경
globalThis === this; // true
globalThis === window; // true
globalThis === self; // true
globalThis === frames; // true

// Node.js 환경(12.0.0 이상)
globalThis === this; // true
globalThis === global; // true
```

전역 객체는 표준 빌트인 객체, 호스트 객체, 그리고 `var` 키워드로 선언한 전역 변수와 전역 함수를 프로퍼티로 갖는다. 전역 객체는 계층 구조상 모든 빌트인 객체의 최상위 객체다.

⚠️하지만 프로토타입 상속 관계상 최상위 객체라는 의미는 아니다.

전역 객체의 특징을 정리하면 다음과 같다.

- 전역 객체는 개발자가 생성할 수 없다. 즉, 전역 객체는 생성자 함수가 없다.
- 전역 객체는 프로퍼티를 참조할 때 식별자를 생략할 수 있다.

  ```js
  // 문자열 'F'를 16진수로 해석하여 10진수로 변환하여 반환한다.
  window.parseInt("F", 16); // -> 15
  // window.parseInt는 parseInt로 호출할 수 있다.
  parseInt("F", 16); // -> 15

  window.parseInt === parseInt; // -> true
  ```

- 모든 표준 빌트인 객체를 프로퍼티로 가진다.
- 브라우저나 Node.js 환경에 따른 호스트 객체를 가진다.
- `var` 키워드로 선언한 전역 변수와 선언하지 않은 변수에 값을 할당한 암묵적 전역, 그리고 전역 함수는 전역 객체의 프로퍼티가 된다.
  > `let`이나 `const` 키워드로 선언한 전역 변수는 전역 렉시컬 환경의 선언적 환경 레코드 내에 존재하게 된다.
- 브라우저 환경의 모든 자바스크립트 코드는 하나의 전역 객체(`window`)를 공유한다. 코드를 분리해도 그렇다.

### 빌트인 전역 프로퍼티

전역 객체의 프로퍼티다. 주로 애플리케이션 전역에서 사용하는 값을 제공한다.

- `Infinity`: 무한대를 의미하는 숫자값
- `NaN`: 숫자가 아님을 의미하는 숫자값(== `Number.NaN`)
- `undefined`: `undefined` 프로퍼티는 원시 타입 `undefined`를 값으로 갖는다.

### 빌트인 전역 함수

전역 객체의 메서드다. 애플리케이션 전역에서 호출할 수 있다.

- `eval`

자바스크립트 코드를 나타내는 문자열을 인수로 전달받아 그 코드가 표현식이라면 런타임에 평가하여 값을 생성하고, 표현식이 아닌 문이라면 문자열 코드를 런타임에 실행한다. 여러 문으로 이루어진 문자열이면 모든 문을 실행한 다음, 마지막 결과값을 반환한다.

`eval` 함수는 기존의 스코프를 런타임에 동적으로 수정한다. 하지만, strict mode에서는 `eval` 함수 자신의 스코프를 생성한다.

```js
const x = 1;

function foo() {
  "use strict";

  // strict mode에서 eval 함수는 기존의 스코프를 수정하지 않고 eval 함수 자신의 자체적인 스코프를 생성한다.
  eval("var x = 2; console.log(x);"); // 2
  console.log(x); // 1
}

foo();
console.log(x); // 1
```

또한 문자열 코드에 `let`이나 `const` 키워드의 변수가 있으면 자동으로 `strict mode`가 적용된다.

`eval` 함수는 다음과 같은 이유로 퇴출당했다. 사용하지 말아야 한다.

1. 사용자로부터 입력받은 코드를 실행하므로 보안에 취약하다.
2. 자바스크립트 엔진에 의해 최적화가 수행되지 않아 처리 속도가 느리다.

- `isFinite`

전달받은 인수가 정상적인 유한수인지 검사하여 불리언 값을 반환한다. 숫자가 아닌 경우 암묵적으로 숫자로 변환하여 검사한다. `NaN`으로 평가되면 `false`를 반환한다.

`isFinite(null)`은 `true`를 반환한다. `null`은 숫자로 변환하면 0이 되기 때문이다.

- `isNaN`

전달받은 인수가 `NaN`인지 검사하여 불리언 값으로 반환한다. 숫자가 아닌 경우 암묵적으로 숫자로 변환하여 검사한다.

- `parseFloat`

전달받은 문자열 인수를 부동 소수점 숫자, 즉 실수로 해석하여 반환한다.

```js
// 문자열을 실수로 해석하여 반환한다.
parseFloat("3.14"); // -> 3.14
parseFloat("10.00"); // -> 10

// 공백으로 구분된 문자열은 첫 번째 문자열만 변환한다.
parseFloat("34 45 66"); // -> 34
parseFloat("40 years"); // -> 40

// 첫 번째 문자열을 숫자로 변환할 수 없다면 NaN을 반환한다.
parseFloat("He was 40"); // -> NaN

// 앞뒤 공백은 무시된다.
parseFloat(" 60 "); // -> 60
```

- `parseInt`

전달받은 문자열 인수를 정수로 해석하여 반환한다. 문자열이 아닌 경우 문자열로 변환한 다음, 정수로 해석하여 반환한다.

두 번째 인수로 진법을 나타내는 기수를 전달할 수 있다. 첫 번째 인수로 전달된 문자열을 해당 기수의 숫자로 해석하여 반환한다. 반환값은 언제나 10진수다.

```js
// 10'을 10진수로 해석하고 그 결과를 10진수 정수로 반환한다
parseInt("10"); // -> 10
// '10'을 2진수로 해석하고 그 결과를 10진수 정수로 반환한다
parseInt("10", 2); // -> 2
// '10'을 8진수로 해석하고 그 결과를 10진수 정수로 반환한다
parseInt("10", 8); // -> 8
// '10'을 16진수로 해석하고 그 결과를 10진수 정수로 반환한다
parseInt("10", 16); // -> 16
```

10진수 숫자를 해당 기수의 문자열로 변환하여 반환하고 싶을 때는 `Number.prototype.toString` 메서드를 사용한다.

```js
const x = 10;

x.toString(2); // 1010
```

첫 번째 인수가 `0x` 또는 `0X`로 시작하는 16진수 리터럴이면 16진수로 해석하여 10진수 정수로 반환한다. (2진수, 8진수는 불가능하다.)

⚠️ES5 이전까진 0으로 시작하는 숫자를 8진수로 해석했다. ES6부터는 10진수로 해석하니 2진수, 8진수는 진수를 반드시 지정해야 한다.

첫 번째 인수가 전달한 문자열의 첫 번째 문자가 해당 진수의 숫자로 변환될 수 없다면 `NaN`을 반환한다. 하지만 두 번째 문자부터 해당 진수를 나타내는 숫자가 아닌 문자와 마주치면 이 문자와 계속되는 문자들은 전부 무시되며 해석된 정수값만 반환한다.

공백으로 구분된 문자열은 첫 번째 문자열만 변환한다.

- `encodeURI` / `decodeURI`

`encodeURI` 함수는 완전한 URI를 문자열로 전달받아 이스케이프 처리를 위해 인코딩한다.

> 이스케이프 처리: 네트워크를 통해 정보를 공유할 때 어떤 시스템에서도 읽을 수 있는 아스키 문자 셋으로 변환하는 것을 의미한다. UTF-8 특수 문자의 경우 1문자당 1~3바이트를 차지하는데, UTF-8 한글 표현의 경우 1문자당 3바이트다. '가'는 `%EC%9E%90`으로 인코딩된다.

RFC3986에 따르면 URL은 아스키 문자 셋으로만 구성되어야 한다. 때문에 대부분의 특수문자나 한글 같은 문자는 이스케이프 처리가 필요하다. 알파벳, 0~9의 숫자, -\_.!~\*'() 문자는 이스케이프 처리하지 않아도 된다.

- `encodeURIComponent` / `decodeURIComponent`

`encodeURIComponent` 함수는 URI 구성 요소(component)를 인수로 전달받아 인코딩한다. (컴포넌트는 쿼리 스트링을 의미한다.)

```js
// URI의 쿼리 스트링
const uriComp = "name=이웅모&job=programmer&teacher";

// encodeURIComponent 함수는 인수로 전달받은 문자열을 URI의 구성요소인 쿼리 스트링의 일부로 간주한다.
// 따라서 쿼리 스트링 구분자로 사용되는 =, ?, &까지 인코딩한다.
let enc = encodeURIComponent(uriComp);
console.log(enc);
// name%3D%EC%9D%B4%EC%9B%85%EB%AA%A8%26job%3Dprogrammer%26teacher

let dec = decodeURIComponent(enc);
console.log(dec);
// 이웅모&job=programmer&teacher

// encodeURI 함수는 인수로 전달받은 문자열을 완전한 URI로 간주한다.
// 따라서 쿼리 스트링 구분자로 사용되는 =, ?, &를 인코딩하지 않는다.
enc = encodeURI(uriComp);
console.log(enc);
// name=%EC%9D%B4%EC%9B%85%EB%AA%A8&job=programmer&teacher

dec = decodeURI(enc);
console.log(dec);
// name=이웅모&job=programmer&teacher
```

### 암묵적 전역

암묵적 전역은 선언하지 않은 식별자를 전역 객체의 프로퍼티로 동적 생성하는 것을 말한다. 변수가 아니므로 변수 호이스팅이 발생하지 않는다.
