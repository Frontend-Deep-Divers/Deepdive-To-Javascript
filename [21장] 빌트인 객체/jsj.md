# 21장 빌트인 객체

# 21.1 자바스크립트 객체의 분류

- 자바 스크립트 객체는 크게 3개의 객체로 분류할 수 있다.
- 표준 빌트인 객체
    - ECMAScript 사양에 정의된 객체.
    - 애플리케이션 전역의 공통 기능을 제공하며 표준 빌트인 객체는 ECMAScript 사양에 정의되어 있기 때문에 자바 스크립트 실행 환경에 관계없이 언제나 사용할 수 있다.
    - 표준 빌트인 객체는 전역 객체의 프로퍼티로서 제공되어 별도의 선언 없이 전역 변수처럼 언제나 참조할 수 있다.
- 호스트 객체
    - ECMAScript 사양에 정의되어 있지는 않지만 자바 스크립트 실행 환경 (브라우저 혹은 Node.js 환경)에서 추가로 제공하는 객체
    - 브라우저 환경에서는 클라이언트 사이드 Web API (DOM, BOM 등등)를 호스트 객체로 제공하고 Node.js 환경에서는 Node.js 고유의 API를 호스트 객체로 제공한다.
- 사용자 정의 객체
    - 표준 빌트인 객체와 호스트 객체처럼 기본 제공되는 객체가 아닌 사용자가 직접 정의한 객체
    

## 21.2 표준 빌트인 객체

- 자바 스크립트에서는 Object, String.. 등 40여개의 표준 빌트인 객체를 제공한다. 이중 Math, Reflect, JSON을 제외한 나머지는 모두 인스턴스를 생성할 수 있는 생성자 함수 객체다.
- 생성자 함수 객체인 경우 : 프로토타입 메서드와 정적 메서드 제공
- 생성자 함수 객체가 아닌 경우 : 정적 메서드만 제공
- 생성자 함수 객체인 경우, 이 표준 빌트인 객체가 생성한 인스턴스의 프로토타입은 표준 빌트인 객체의 prototype 프로퍼티에 바인딩된 객체다. 
( ex) String을 생성자 함수로 호출하여 생성한 String 인스턴스의 프로토타입 : String.prototype)
- 이렇게 prototype 프로퍼티에 바인딩된 객체는 다양한 기능의 빌트인 프로토타입 메서드를 제공한다. 또한, 인스턴스 없이 호출 가능한 빌트인 정적 메서드 또한 제공한다.

## 21.3 원시값과 래퍼 객체

- **원시값(문자열, 숫자, 불리언 값)에 대해 객체처럼 접근하면 자바 스크립트 엔진은 일시적으로 이 원시값을 연관된 객체로 변환해준다. 이때 생성되는 임시 객체를 래퍼 객체 라고 한다.**
    
    ```jsx
    const str = 'hello';
    
    //원시 타입인 문자열이 프로퍼티와 메서드를 갖고 있는 객체처럼 작동한다.
    //위 설명에서 객체처럼 접근한다는건 아래 예시처럼 마침표 표기법 등으로 접근하는 것을 의미한다.
    console.log(str.length);
    console.log(str.toUpperCase());
    ```
    
- 래퍼 객체의 생성 과정
    - 문자열에 대해 마침표 표기법으로 접근하면 그 순간 래퍼 객체인 string 생성자 함수의 인스턴스가 생성되고 문자열은 래퍼 객체의 `[[StringData]]`  내부 슬롯에 할당된다.
    (이때 문자열 래퍼 객체인 String 생성자 함수의 인스턴스는 String.prototype의 메서드를 상속받아 사용할 수 있다.)
        
        ![image.png](21%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%87%E1%85%B5%E1%86%AF%E1%84%90%E1%85%B3%E1%84%8B%E1%85%B5%E1%86%AB%20%E1%84%80%E1%85%A2%E1%86%A8%E1%84%8E%E1%85%A6%201c2f78a2bff180139d23f025b239b284/image.png)
        
        (Object.prototype 은 모든 객체의 프로토타입 체인의 최상위에 있기에 저렇게 연결이 된다.)
        
    - 이후 래퍼 객체의 처리가 종료되면 래퍼 객체의 `[[StringData]]`  내부 슬롯에 할당된 원시값으로 원래의 상태(식별자가 원시값을 가지는)로 되돌리고 래퍼 객체는 가비지 컬렉션의 대상이 된다.
    - 과정
        
        ```jsx
        //1. 식별자 str은 문자열을 값으로 갖는다.
        const str = 'hello';
        
        //2. 식별자 str은 암묵적으로 생성된 래퍼 객체를 가리킨다.
        //이후 식별자 str의 값은 래퍼 객체의 [[StringData]] 내부 슬롯에 할당된다.
        //래퍼 객체에 name 프로퍼티가 동적 추가된다.
        str.name = 'Lee';
        
        //3. 이후 식별자 str은 다시 원래의 문자열 값(래퍼 객체의 [[StringData]] 내부 슬롯에 할당된 원시값)을 가진다.
        //2에서 생성된 래퍼객체는 아무도 참조하지 않게되어 가비지 컬렉션의 대상이 된다.
        
        //4. 식별자 str은 새롭게 암묵적으로 생성된 래퍼 객체를 가리킨다.(2의 래퍼객체와는 다른)
        //새롭게 생성된 래퍼 객체에는 name프로퍼티가 존재하지 않는다.
        console.log(str.name); //undefined 출력
        
        //5. 식별자 str은 다시 원래의 문자열을 가지며 이때 4에서 생성된 래퍼객체 또한 가비지 컬렉션의 대상이 된다.
        console.log(typeof str, str); //string hello
        ```
        
- Symbol의 경우에도 래퍼 객체를 생성하지만 일반적인 원시값과는 달리 리터럴 표기법으로 생성이 안되며 Symbol함수로만 생성이 가능하다.
- 원시값들 (null, undefined 제외)은 암묵적으로 생성되는 래퍼 객체에 의해 마치 객체처럼 사용될 수 있으며 표준 빌트인 객체의 프로토타입 메서드나 프로퍼티를 참조할 수 있다.

## 21.4 전역 객체

- 코드가 실행되기 이전 단계에 자바 스크립트 엔진에 의해 어떤 객체보다도 먼저 생성되는 특수한 객체이며, 어떤 객체에도 속하지 않은 최상위 객체이다.
- 브라우저에서는 window(일반적으로), Node.js 환경에서는 global이 전역 객체를 가리킨다.
- 전역 객체의 특징
    - 개발자가 의도적으로 생성할 수 없다. (전역 객체를 생성하는 생성자 함수 제공 X)
    - 전역 객체의 프로퍼티를 참조할 때 window(혹은 global)를 생략할 수 있다.
    - 전역 객체는 Object, String 등 모든 표준 빌트인 객체를 프로퍼티로 가진다.
    - 자바 스크립트 실행환경 (브라우저나 Node.js 환경)에 따라 추가적으로 프로퍼티와 메서드를 갖는다. (호스트 객체)
    - var 키워드로 선언한 전역 변수와 암묵적 전역(선언하지 않은 변수에 값을 할당), 전역 함수는 전역객체의 프로퍼티가 된다.
    - let 이나 const 키워드로 선언한 전역 변수는 전역 객체의 프로퍼티가 X (이들은 보이지 않는 개념적인 블록인 전역 렉시컬 환경의 선언전 환경 레코드에 존재한다.)
    - 브라우저 환경의 모든 자바 스크립트 코드는 하나의 전역 객체 window를 공유하며 여러개의 script 태그를 통해 자바 스크립트 코드를 분리해도 하나의 전역 객체 window를 공유하는 것은 변함이 없다. (하나의 전역을 공유함)
- 전역 객체의 프로퍼티/메서드
    - 빌트인 전역 프로퍼티
        - 전역 객체의 프로퍼티.
        - 애플리케이션 전역에서 사용하는 값을 제공함 (Nan, Infinite, undefined)
    - 빌트인 전역 함수
        - 애플리케이션 전역에서 호출할 수 있는 빌트인 함수 (전역 객체의 메서드)
        - `eval`
            - 자바 스크립트 코드를 나타내는 문자열을 인수로 전달받아서 문자열 코드가 표현식이라면 해당 문자열 코드를 런타임에 평가하여 값을 생성하고, 표현식이 아닌 문이라면 해당 문자열 코드를 런타임에 실행한다.
            - 여러개의 문으로 이루어져 있다면 모든 문을 실행한다.
            - 사용 코드
                
                ```jsx
                eval('1 + 2'); //3
                eval('var x = 5'); //undefined
                
                console.log(x); //5 -> 위의 eval함수에 의해 런타임에 변수 선언문이 실행되어 x 변수가 선언되었기 때문
                
                const o = eval('({a:1})');
                const f = eval('(function() { return 1;})');
                //객체 리터럴과 함수 리터럴은 반드시 괄호로 둘러싸야 한다.
                ```
                
            - eval 함수는 기존의 스코프를 런타임에 동적으로 수정하므로 eval 함수에 전달된 코드는 이미 그 위치에 존재하던 코드처럼 작동한다.
            - 하지만 strict mode에서는 기존의 스코프를 수정하지 않고 eval 함수 자신의 자체적인 스코프를 생성한다.
            - eval 함수를 통해 실행되는 코드는 최적화가 수행되지 않으므로 매우 느리고, 사용자로부터 입력받은 콘텐츠를 실행하게 되면 보안에 매우 취약해지는 단점이 있어 사용을 금지해야한다.
        - isFinite
            - 전달받은 인수가 유한하면 true, 무한하면 false를 반환한다.
            - 타입이 숫자가 아니면 숫자로 타입을 변환하여 검사하며, NaN인 경우에는 false를 반환한다. (null은 0으로 평가되어 true 반환)
        - isNaN
            - 전달받은 인수가 NaN인지 검사하여 boolean 값으로 반환.
            - 마찬가지로 숫자로 타입을 변환하여 검사한다.
        - parseFloat
            - 전달받은 문자열 인수를 부동 소수점 숫자(실수)로 해석하여 반환한다.
        - parseInt
            - 전달받은 문자열 인수를 정수로 해석하여 반환한다.
            - 두번째 인수로 진법을 나타내는 매개변수를 전달할 수 있다. 이를 통해 전달받은 인수를 해당 진법으로 가정하여 해석한다.
        - encodeURI/decodeURI
            - 완전한 URI를 문자열로 전달받아 이스케이프 처리를 위해 인코딩
            인코딩된 URI를 인수로 전달받아 이스케이프 처리 이전으로 디코딩한다.
        - encodeURIComponent/decodeURIComponent
            - URI 구성 요소를 인수로 전달받아 인코딩
            전달된 URI 구성요소를 디코딩한다.
            
        
        > ❓URI, 이스케이프 처리, 인코딩
        > 
        > - URI : 인터넷에 있는 자원을 나타내는 유일한 주소 
        > (하위 개념으로 URL, URN)
        > - 이스케이프 처리 : 네트워크를 통해 정보를 공유할 때 어떤 시스템에서도 읽을 수 있는 아스키문자 set으로 변환하는 것
        > - 인코딩 : URI의 문자들을 이스케이프 처리하는 것

- 암묵적 전역
    - **선언하지 않은 식별자에 값을 할당하면 전역 객체의 프로퍼티가 되어 전역 변수처럼 동작한다.**
    - 하지만 변수 선언이 아닌 전역 객체의 프로퍼티로 추가되었기에 변수가 아니므로 변수 호이스팅은 발생하지 않는다.
    - 이렇게 추가된 프로퍼티는 delete연산자로 삭제할 수 있지만, 전역 변수는 프로퍼티이지만 delete로 삭제할 수 없다.