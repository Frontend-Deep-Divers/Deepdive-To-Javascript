# 12장 함수

## 12.1 함수란?

- **일련의 과정을 문으로 구현하고 코드 블록으로 감싸서 하나의 실행 단위로 정의한 것**
- 함수의 구성 요소
    
    ![image.png](12%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%92%E1%85%A1%E1%86%B7%E1%84%89%E1%85%AE%201bcf78a2bff1808aab46cfd6ecb38c04/image.png)
    

## 12.2 함수를 사용하는 이유

- 코드의 재사용
    - 동일한 작업을 반복적으로 수행해야 할 때 같은 코드를 중복해서 여러 번 작성하는 것이 아니라 함수를 재사용 하는 것이 효율적이다.
- 유지 보수의 편의성, 코드의 신뢰성, 코드의 가독성 향상

## 12.3 함수 리터럴

- 자바 스크립트의 함수는 객체 타입의 값으로 다른 요소들 처럼 리터럴로 생성할 수 있다. 함수 리터럴의 구성 요소는 다음과 같다.
    
    ![image.png](12%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%92%E1%85%A1%E1%86%B7%E1%84%89%E1%85%AE%201bcf78a2bff1808aab46cfd6ecb38c04/image%201.png)
    
    ```jsx
    var f = function add(x, y){
    	return x+y;
    }
    ```
    
- **함수는 객체지만 일반 객체와 달리 호출할 수 있다.** 또한 일반 객체에 없는 함수 객체만의 고유한 프로퍼티를 갖는다.

## 12.4 함수 정의

- 함수를 호출하기 이전에 인수를 전달받을 매개변수와 실행할 문들, 반환할 값들을 지정하는 것을 의미한다.
- 함수 정의 방식 4가지
    
    ![image.png](12%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%92%E1%85%A1%E1%86%B7%E1%84%89%E1%85%AE%201bcf78a2bff1808aab46cfd6ecb38c04/image%202.png)
    
- **변수는 “선언” 이지만 함수는 “정의” 이다. 이는 함수 선언문이 평가되면 식별자가 암묵적으로 생성되고 함수 객체가 할당되기 때문이다.**
- 함수 선언문
    - 함수 선언문은 함수 리터럴과 형태가 동일하다. 허나 **함수 리터럴은 함수 이름을 생략할 수 있지만, 함수 선언문은 함수 이름을 생략할 수 없다.**
    - **함수 선언문은 표현식이 아닌 문이다.**
        
        ```jsx
        // 함수 선언문은 표현식이 아닌 문이므로 변수에 할당할 수 없다.
        // 아래 선언문을 보면 함수 선언문이 변수에 할당된 것처럼 보인다.
        var add = function add(x,y){
        	return x+y;
        };
        
        //함수 호출
        console.log(add(2,5));
        
        //허나 이는 자바 스크립트 엔진이 코드의 문맥에 따라 위의 예시를 
        //함수 선언문이 아니라 함수 리터럴 표현식으로 해석했기 때문이다.
        //함수 선언문과 함수 리터럴은 함수 이름을 생략할 수 없다는 것만 빼면 
        //형태가 동일하므로 기명 함수 리터럴(함수 이름이 있는 함수 리터럴)의 경우
        //함수 선언문 혹은 함수 리터럴 표현식으로 해석될 가능성이 있다는 것이다.
        
        //함수 선언문, 함수 리터럴 표현식 둘다 함수가 생성되는 것은 동일하나
        //함수 내부 동작에 차이가 있다.
        
        function foo() { console.log('foo')};
        foo();
        //이 경우 기명 함수 리터럴을 단독으로 사용하여 함수 선언문으로 해석된다.
        //함수 선언문의 경우 함수 이름을 생략할 수 없다.
        
        (function bar(){console.log('bar'); });
        bar(); //ReferenceError : bar is not defined
        
        //이 경우 함수 리터럴을 피연산자로 사용하여 함수 선언문이 아닌
        //함수 리터럴 표현식으로 해석되어 함수몸체 외부에서 함수를 호출할 수 없다.
        //(위의 함수 리터럴의 함수 이름 참고)
        ```
        
    - **자바 스크립트 엔진은 생성된 함수를 호출하기 위해 함수 이름과 동일한 이름의 식별자를 암목적으로 생성하고, 거기에 함수 객체를 할당한다.**
    - **함수는 함수 이름이 아니라 함수 객체를 가리키는 식별자로 호출하는 것이다.**
- 함수 표현식
    - 자바 스크립트의 함수는 일급 객체이며 함수 리터럴로 생성한 함수 객체를 변수에 할당할 수 있다. 이러한 함수 정의 방식을 함수 표현식이라고 한다.
        
        ```jsx
        var add = function (x,y) {
        	return x+y;
        }
        
        console.log(add(2,5));
        ```
        
    - 함수 리터럴의 함수 이름은 생략할 수 있기에 (익명 함수) 함수 표현식의 함수 리터럴은 함수 이름을 생략하는 것이 일반적이다.
    
    ```jsx
    var add = function foo (x, y) {
    	return x+y;
    }
    
    console.log(add(2,5)); 
    
    console.log(foo(2,5)); 
    //이 경우 함수 이름으로 호출한 것인데, 함수 이름은 함수 몸체 내부에서만
    //유효하므로 referenceError가 발생한다.
    ```
    
    - 함수 선언문은 “표현식이 아닌 문”(`할당X`), 
    함수 표현식은 “표현식인 문”이다.
- 함수 생성 시점과 함수 호이스팅
    
    ```jsx
    console.log(add(2,5));
    console.log(sub(2,5)); //Error
    
    //함수 선언문 (함수 선언전 호출 O)
    function add(x,y){
    	return x+y;
    };
    
    //함수 표현식 (함수 선언전 호출 X)
    var sub = function(x,y){
    	return x-y;
    };
    ```
    
    - **함수 선언문으로 정의한 함수와 함수 표현식으로 정의한 함수의 생성 시점이 다르다!**
    - 함수 선언문도 다른 선언문들 처럼 런타임 이전에 자바 스크립트 엔진에 의해 먼저 실행되어 함수 객체가 먼저 생성되기 때문이다.
    - **함수 호이스팅** : **함수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징**
    - 함수 표현식은?
        - 위의 예시처럼 **함수 표현식의 경우 변수에 함수 리터럴을 할당하는 문이기 때문에, 변수 할당문으로 동작한다.**
        - **변수 할당문의 값은 할당문이 실행되는 시점인 런타임에 평가되므로 함수 표현식의 함수 리터럴 또한 할당문이 실행되는 시점에 평가되어 함수 객체가 된다.**
        - 따라서 함수 표현식으로 함수를 정의하면 **함수 호이스팅이 아닌 변수 호이스팅이 발생되어 `undefined`로 평가된다..**
        - 함수 표현식에 의한 함수 생성 그림
            
            ![image.png](12%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%92%E1%85%A1%E1%86%B7%E1%84%89%E1%85%AE%201bcf78a2bff1808aab46cfd6ecb38c04/image%203.png)
            

- Function 생성자 함수
    - 자바 스크립트에서 기본 제공되는 빌트인 함수 function 함수에 매개변수 목록 + 함수 몬체를 문자열로 전달하면서 new 연산자와 함께 호출
        
        ```jsx
        var add = new Function('x','y','return x+y');
        ```
        
    - new를 안써도 결과는 동일하다.
    - function 생성자로 생성하는 방식은 다른 함수들과 좀 다르게 동작하기에 일반적이지 않은 방식임.
- 화살표 함수
    - ES6에서 도입되어 좀 더 간략하게 함수를 선언할 수 있으며, 항상 익명 함수로 정의함
        
        ```jsx
        const add = (x,y)=> x+y;
        console.log(add(2,5));
        ```
        

## 12.5 함수 호출

- 함수를 호출하면 현재의 실행 흐름을 중단하고 호출된 함수로 실행 흐름을 옮겨 함수 몸체의 문들을 실행시킨다.
- 매개변수(parameter)와 인수(arguments)
    - 함수를 실행하기 위해 필요한 값을 함수 외부에서 내부로 전달할 필요가 있는경우, 매개변수를 통해 인수를 전달한다.
    - 매개변수는 함수를 정의할 때 선언하며, 함수 몸체 내부에서 변수와 동일하게 취급된다.
    - 함수가 호출되면 함수 몸체 내에서 암묵적으로 매개 변수가 생성되고, `undefined`로 초기화 된 후, 인수가 순서대로 할당된다.
        
        ![image.png](12%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%92%E1%85%A1%E1%86%B7%E1%84%89%E1%85%AE%201bcf78a2bff1808aab46cfd6ecb38c04/image%204.png)
        
    - 함수는 매개변수와 인수의 개수가 일치하지 않는지 체크하지 않으며, 따로 에러가 발생하지는 않는다.
    - 인수가 부족해서 인수가 할당되지 않은 매개변수의 값은 `undefined`이다.
    - 매개변수보다 인수가 많아서 초과된 경우 무시된다. 허나 그냥 버려지는 것은 아니고 `arguments` 객체의 프로퍼티로 보관이 된다.
- 인수 확인
    
    ```jsx
    function add(x,y){
    	return x+y;
    }
    //이렇게 2개의 숫자를 더해서 반환하는 함수로 기획을 했지만
    
    add(2); //NaN
    add('a','b') //'ab'
    
    //이렇게 뜻하지 않은 결과를 가져올 수 있게 된다.
    //그 이유는 아래와 같다.
    ```
    
    - 자바 스크립트 함수는 매개변수와 인수의 개수가 일치하는지 확인하지 X
    - 자바 스크립트는 동적 타입 언어로, 매개변수의 타입을 사전에 지정할 수 X
    - 따라서 함수를 정의할 때 적절한 인수가 전달되었는지 확인할 필요가 있다.
        
        ```jsx
        //예시
        function add(x,y){
        	//매개 변수를 통해 전달된 인수의 타입 체크
        	if(typeof x !== 'number' || typeof y !== 'number'){
        		 throw new TypeError('인수는 모두 숫자값이어야 합니다.');
        	}
        	return x+y;
        }
        ```
        
    - 사실 이래도 런타임에 에러가 발생하므로 함수의 부적절한 호출을 사전에 방지할 수는 없다.
    - 타입 스크립트 처럼 정적 타입을 선언할 수 있는 자바 스크립트의 상위 확장 도입하거나
    - 단축 평가를 통해 매개 변수에 기본 값을 할당하는 방법 또한 존재한다.
        
        ![image.png](12%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%92%E1%85%A1%E1%86%B7%E1%84%89%E1%85%AE%201bcf78a2bff1808aab46cfd6ecb38c04/image%205.png)
        
    - ES6에 도입된 매개변수 기본값은 매개변수에 인수를 전달하지 않았을 경우, `undefined`를 전달한 경우에 유용하다.
        
        ![image.png](12%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%92%E1%85%A1%E1%86%B7%E1%84%89%E1%85%AE%201bcf78a2bff1808aab46cfd6ecb38c04/image%206.png)
        
- 매개변수의 최대 개수
    - 매개 변수의 경우, 최대 3개 이상을 넘지 않는 것을 권장하고 있다. **이상적인 함수는 한가지 일만 해야하며 가급적 작게 만들어야한다.**
    - 3개 이상의 매개변수가 필요한 경우, 객체를 인수로 전달해도 된다.
- 반환문
    - `return` 키워드와 표현식(반환값)으로 이루어진 반환문으로 실행 결과를 함수 외부로 반환할 수 있다.
    - **함수 호출은 표현식**이기 때문에 함수 호출 표현식은 반환값으로 평가된다.
    

## 12.6 참조에 의한 전달과 외부 상태의 변경

- 매개변수도 함수 몸체 내부에서 변수와 동일하게 취급되므로 값에 의한 전달, 참조에 의한 전달 방식을 그대로 따른다.
- 인수가 원시 타입이라면 원시값이 불변이기에 원본 값이 함수에 의해 훼손되지 않지만, 객체 타입이라면 변경이 가능하여 재할당이 이뤄지지 않고 함수가 원본 객체를 변경할 수 있게 된다.
- 옵저버 패턴을 통해 객체의 변경을 추적하거나, 불변 객체로 만들어 객체의 복사본을 새롭게 생성하고(비용은 많이 들겠지만) 객체를 원시 값처럼 변경 불가능한 값으로 동작하게 한다.
- 순수함수
    - 외부 상태를 변경하지 않고 외부 상태에 의존하지도 않는 함수
    - 순수 함수를 통해 부수 효과를 억제하고 오류를 피해 프로그램의 안정성을 높이려는 패러다임을 함수형 프로그래밍이라고 한다.

## 12.7 다양한 함수의 형태

- 즉시 실행 함수
    - 함수 정의와 동시에 즉시 호출되는 함수
    - 한번만 호출되며 다시 호출할 수 없다.
        
        ```jsx
        //익명 즉시 실행 함수
        (function (){
        	var a = 3;
        	var b = 5;
        	return a * b;
        }());
        
        //기명 즉시 실행 함수
        (function foo(){
        	var a = 3;
        	var b = 5;
        	return a * b;
        }());
        foo(); //Error : 함수 이름은 함수 몸체에서만 참조할 수 있기 때문
        
        //일반적으로는 익명 즉시 실행 함수를 사용하는 것이 일반적이다.
        ```
        
    - 즉시 실행 함수는 그룹 연산자 `( … )` 로 감싸야 한다. 함수 정의가 함수 선언문의 형식에 맞지 않기 때문.
    - 즉시 실행 함수도 일반 함수처럼 값을 반환하거나 인수를 전달할 수도 있다.
        
        ```jsx
        var res = (function(){
        	var a = 3;
        	var b = 5;
        	return a*b;
        }()); //15반환
        
        res = (function(a,b){
        	return a*b;
        }(3,5));
        res //15
        ```
        
- 재귀 함수
    - 함수가 자기 자신을 호출하는 재귀 호출을 수행하는 함수
    - 재귀 함수는 반복문 없이 반복되는 처리를 구현할 수 있지만 무한 반복에 빠질 위험이 있고 이로 인해 스택 오버플로 에러가 발생할 수 있으니 한정적으로 사용하자.
- 중첩 함수
    - 함수 내부에 정의된 함수
    - 외부 함수 : 중첨 함수를 포함하는 함수
        
        ```jsx
        function outer(){
        	var x = 1;
        	
        	function inner(){
        		var y = 2;
        		console.log(x+y);
        	}
        	
        	inner();
        }
        
        outer();
        ```
        
    - ES6부터 함수 정의는 문이 위치할 수 있는 문맥이면 어디든지 가능하다. 허나 호이스팅으로 인한 혼란을 막기 위해 if문 같은 코드 블록에서 함수 선언문을 통해 함수를 정의하는 것은 바람직하지 않다.
- 콜백 함수
    - 함수의 변하지 않는 공통 로직은 미리 정의해 두고, 경우에 따라 변경되는 로직은 추상화해서 함수 외부에서 내부로 전달한다.
        
        ```jsx
        function repeat(n, f){
        	for (var i = 0; i < n; i++){
        		f(i);
        	}
        }
        
        var logAll = function(i){
        	console.log(i);
        };
        
        repeat(5, logAll); //반복호출할 함수를 인수로 전달
        ```
        
    - **콜백 함수** : 함수의 매개변수를 통해 다른 함수의 내부로 전달되는 함수
    - **고차 함수** : 매개 변수를 통해 함수의 외부에서 콜백 함수를 전달받은 함수
    - **고차 함수는 콜백 함수를 자신의 일부분으로 합성한다. 콜백 함수의 호출 시점을 결정해서 호출한다.**
    - **콜백 함수는 고차함수에 의해 호출되며, 고차 함수는 필요에 따라 콜백 함수에 인수를 전달할 수 있다.**
    - 콜백 함수는 함수형 프로그래밍 패러다임, 비동기 처리, 배열 고차함수 (`map`, `filter` 등)에 쓰인다.
- 순수 함수와 비순수 함수
    - 순수 함수
        - 어떤 외부 상태에 의존하지 않고 변경하지도 않는 함수.
        - 동일한 인수가 전달되면 언제나 동일한 값을 반환함.
        - 오직 매개변수를 통해 전달된 인수에게만 의존하여 값 생성 및 반환
    - 비순수 함수
        - 외부 상태에 의존하거나 외부 상태를 변경하는 함수
        - 외부 상태를 참조하지 않아도 매개 변수를 통해 객체를 전달받으면 비순수 함수가 된다.