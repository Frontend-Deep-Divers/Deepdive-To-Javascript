# 12.1 함수

---

- 자바스크립트의 핵심 개념으로 스코프, 실행 컨텍스트, 클로저, 생성자 함수에 의한 객체 생성, 메서드, this, 프로토타입, 모듈화 등 모든 것이 관련이 있음.
- 💬 프로그래밍 언어의 함수는 일련의 과정을 문으로 구현하고 코드 블록으로 감싸서 하나의 실행 단위로 정의한 것이다.
- 전달 받는 변수: **매개변수**, 입력: **인수**, 출력: **반환값**
- 함수는 정의를 통해 생성되고, 호출을 통해 실행된다. 함수 정의, 함수 호출

# 12.2 함수를 실행하는 이유

---

- 함수는 필요할 때마다 재사용할 수가 있다. 즉, 코드의 재사용 측면에서 유리하다.
- 함수의 장점
  - 유지보수성의 편의성: 이후에 중복된 코드보다 수정에 시간이 덜걸림.
  - 코드의 신뢰성: 실수를 줄여서 신뢰성을 높임.
  - 코드의 가독성: 함수 내부 코드를 이해하지 않더라도 역할을 파악할 수 있게 도움.
- ❗가독성이 좋은 코드가 좋은 코드이다.

# 12.3 함수 리터럴

---

- 함수 리터럴로 생성할 수 있음.
- function 키워드, 함수 이름, 매개변수 목록, 함수 몸체
- ❗ 함수 리터럴의 구성요소
  - **함수 이름**
    - 식별자임
    - **🌟 함수 이름은 함수 몸체 내에서만 참조할 수 있는 식별자다**
    - 함수 이름은 생략할 수 있음 (무명 / 익명 함수)
  - **매개변수**
    - 0 개 이상
    - 순서대로 할당
    - 함수 몸체 내에서 **변수와 동일하게 취급된다.** 따라서 식별자 규칙 준수
  - **함수 몸체**
    - 일관적으로 실행될 문들을 하나의 실행 단위로 정의
    - 함수가 호출될 때 실행
- 🌟 **함수는 객체다. 하지만 일반 객체와는 좀 다르다. →** 일반 객체는 호출 불가, 함수는 가능, 또한 객체에는 없는 고유한 프로퍼티 가지고 있음.
- 함수가 객체라는 사실은 자바스크립트의 특징이다. → 18장 함수와 일급 객체에서 살펴봅시다.

# 12.4 함수 정의

---

- 함수를 정의하는 방법 4가지 (난 보통 선언문 혹은 화살표 함수를 사용하는 듯)
  - 함수 선언문
  - 함수 표현식
  - Function 생성자 함수
  - 화살표 함수(ES6)

1. **함수 선언문**

   ```jsx
   function add(a, b) {
     return a + b;
   }
   ```

   - 위와 같이 정의
   - 함수 선언문은 함수 이름 생략 불가
   - **함수 선언문은 표현식이 아닌 문이다.** (표현식이란 값으로 평가될 수 있는 문)
   - ⚠️ 콘솔에서 선언문을 실행하면 표현식이 아니기 때문에 undefined 가 나온다!
   - 표현식이 아닌 문은 변수에 할당할 수 없지만, 아래 예제는 마치 할당된 것처럼 보인다.

   ```jsx
   var add = function add(a, b) {
     // 이것도 선언문 처럼 보이지만 표현식으로 해석된 것!!
     return a + b;
   };

   console.log(add(2, 5)); // 7
   ```

   - 하지만 표현식이 아닌 문은 할당할 수 없다. 그럼 위는 어떻게 가능한 것인가?
   - **❗ 그 이유는 바로 함수 리터럴이 사용된 방식에 따라 함수 선언문으로 해석될 수도 있고 함수 표현식으로 해석될 수 있기 때문이다.**

   ```jsx
   function foo() {
     console.log("foo");
   }

   foo(); // 위는 함수 선언문으로 해석되어 제대로 동작되지만

   (function bar() {
     console.log("bar");
   });

   bar(); // 아래는 함수 표현식으로 해석되어  referenceError: bar이 정의되어 있지 않습니다.
   ```

   - 어째서 함수 선언문은 호출할 수 있지만 함수 표현식은 호출할 수 없는 것일까? → 그 이유는 12.3절 “함수 이름은 함수 몸체 내에서만 참조할 수 있는 식별자다” 라는 것과 관련이 있다. 즉, bar 는 함수 몸체 내부에 있는 함수 이름이기 때문에 호출할 수 없다.
   - **🤔 그렇다면 foo 는 어떻게 호출할 수 있는 것일까? → 그 이유는 함수 선언문은 자바스크립트 엔진이 이를 해석하여 함수 이름과 동일한 이름의 식별자를 생성하여 그 식별자에 함수 객체를 할당하기 때문이다!**

   ```jsx
   var add = function add(a, b) {
     return a + b;
   };
   ```

   - 함수는 함수 이름이 아닌 함수 객체를 가르키는 식별자를 호출한다. 만약 function add 식으로 함수 선언문을 작성하면 위와 같은 방식으로 자바스크립트 엔진이 식별자에 할당하는 것이다.

1. **함수 표현식**

   - 함수는 일급 객체로 변수에 할당 되거나 프로퍼티 값이 되거나, 배열 요소가 될 수 있다. 이처럼 함수를 함수 리터럴로 생성하여 함수 객체를 변수에 할당할 수 있는데 이런 정의 방식을 함수 표현식이라고 한다.

   ```jsx
   var add = function (a, b) {
     return a + b;
   };

   console.log(add(2, 5));
   ```

   - 함수 리터럴의 함수 이름은 생략할 수 있다. 함수 표현식의 함수 리터럴은 보통 생략하는 것이 일반적이다.

   ```jsx
   var add = function foo(a, b) {
     return a + b;
   };

   console.log(add(2, 5)); // 7
   console.log(foo(2, 5)); // 참조 에러 발생!
   ```

   - 함수 이름은 함수 몸체 내부에서만 유효하게 동작하므로 호출 불가! 위처럼 함수 표현식과 함수 선언문은 동작의 차이가 존재한다. 그리고..

1. **함수 생성 시점과 함수 호이스팅 🌟**

   ```jsx
   console.log(fun1(1)); // 1
   console.log(fun2(1)); // typeError fun2 는 함수가 아님!

   function fun1(a) {
     return a;
   }

   var fun2 = function (a) {
     return a;
   };
   ```

   - 함수 선언문과 함수 표현식은 위와 같은 동작 차이도 보인다.
   - 저러한 동작 차이가 발생하는 원인은 바로 **함수 호이스팅** 때문!
   - 함수 호이스팅이 뭐길레..? → 함수 선언문은 런타임 이전에 함수 객체가 먼저 생성되고, 암묵적으로 함수 이름과 동일한 식별자에 함수 객체를 할당한다. 하지만 함수 표현식은 변수에 할당되는 시점에 평가되어 함수 객체가 된다. (변수의 할당과 동일하게 작용)
   - 🌟**따라서, 함수 선언문에는 함수 호이스팅이 함수 표현식에서는 변수 호이스팅이 발생하는 것이다.**
   - 함수 호이스팅은 함수를 사용하기 이전에 함수를 선언해야 한다는 규칙을 무시한다. 이것 때문에 함수 선언문 대신 함수 표현식을 권장하기도 한다.

1. Function 생성자 함수

   - 잘 사용되지 않는다. 권장하지 않는다.
   - ❗ 왜냐하면 Function 생성자를 통해 생성한 함수는 클로저를 생성하지 않는 등 다르게 동작하기 때문!

1. 화살표 함수 (ES6)

   - ES6 에서 도입된 문법으로 좀 더 간략한 방법으로 함수를 선언하는 방식이다. 화살표 함수는 익명 함수로 정의한다.

   ```jsx
   const add = (x, y) => x + y;
   console.log(add(1, 2)); // 3
   ```

   - 다만 완전히 대체하는 녀석은 아니다. 표현 뿐만 아니라 내부 동작도 간략화되어 있다. this 바인딩, prototype 프로퍼티가 없고 arguments 객체를 생성하지 않는다고 함!! → 추후 26장에서 다룰 예정

# 12.5 함수 호출

---

- 함수를 호출하면 현재의 실행 흐름을 중단하고 호출된 함수로 실행 흐름을 옮긴다.
- 함수가 호출되면 함수 몸체 내부에서 암묵적으로 매개변수가 생성되고, 일반 변수와 마찬가지로 undefined로 초기화된 이후 인수가 순서대로 할당된다.

1. **매개 변수와 인수**

   - 매개변수의 스코프는 함수 내부!
   - 인수만큼 인수를 보내지 않는 경우 남은 매개변수는 undefined 이다.

   ```jsx
   const add = (x, y) => x + y;
   console.log(add(1)); // NaN
   ```

   - 인수가 더 많은 경우에는 무시한다. → ❗ 사실 암묵적으로 arguments 객체의 프로퍼티로 보내진다..! 이는 가변 인자 함수를 구현할 때 유용하게 사용된다!

1. **인수 확인**

   - 자바스크립트는 어떠한 타입의 인수를 맞게 전달했는지, 개수를 맞게 전달했는지 코드 작성 중에 확인이 어려울 수 있다. 그래서 정의할 때 인수가 정확하게 전달되었는지 확인할 필요가 있다.
   - 이를 보완하기 위해 타입스크립트이다!
   - 확인 방법
     - 들어온 타입이 정확한지 확인
     - 단축 평가로 기본값 할당

1. **매개변수의 최대 개수**

   - 매개 변수는 적으면 적을수록 좋다. 0개가 가장 이상적이다. (매개변수가 많아지면, 오류가 발생하거나 이해하기 어려움 등 단점이 많다.
   - 3개 이상 안 넘는 거 권장
   - 만약 함수에 인자로 객체를 넘기게 되면 부수효과가 발생한다. 참조에 의한 전달이기 때문.

1. **반환문**
   - return 키워드와 표현식으로 실행 결과를 반환한다.
   - 반환문의 역할
     1. 반환문은 함수 실행을 중단시키고 몸체를 빠져나간다.
     2. return 뒤의 표현식 평가해 반환한다.
   - return 뒤에 없거나 생략하는 경우 undefined 가 반환됨.
   - 반환문은 함수 몸체 내부에서만 사용할 수 있다.
   - ❗ 참고로, Node.js는 모듈 시스템에 의해 파일별로 독립적인 파일 스코프를 가지고 있기 때문에 파일의 가장 바깥에 반환문을 사용해도 에러가 발생하지 않는다!

# 12.6 참조에 의한 전달과 외부 상태의 변경

---

- 값에 의한 전달과 참조에 의한 전달 방식으로 동작한다.
- 매개변수도 동일해서 값에 의한 호출, 참조에 의한 호출로 구별해 부른다. 동작은 사실상 동일하긴 하다. (위 아이들도 사실 동일하다. 뭐가 저장되어 있느냐의 차이지)
- 하여간 이로 인해 참조에 의한 호출로 넘어가게 되면 부수효과 (side effect) 가 발생하게 된다. 변경 가능한 값이기 때문에 함수 안에서 변경하면 원본이 훼손된다.
- 만약 함수 안에서 외부 상태를 변경하면 상태 변화를 추적하기 많이 어려워지고, 코드의 복잡성을 높이게 된다.
- 이 현상은 객체가 변경할 수 있는 값이기에 발생하는 문제이다.
- 이러한 문제의 해결 방법 중 하나는 불변 객체로 만들어 사용하는 것이다. → 객체를 새롭게 생성하는 비용은 들지만 변경 불가능한 값으로 동작하게 만드는 것이다!
- 필요한 경우에는 깊은 복사를 통해 새로운 객체를 생성하고 재할당을 통해 교체한다.
- 외부 상태를 변경하지 않고 외부 상태에 의존하지도 않는 함수를 **순수함수**라고 한다. 순수함수를 통해 부수 효과를 최대한 억제하고 오류를 피하고 프로그램의 안정성을 높이려는 패러다임을 함수형 프로그래밍이라고 한다.

# 12.7 함수의 다양한 형태

---

1. **즉시 실행 함수**

   - 말 그래도 정의와 동시에 즉시 호출되는 함수로 단 한 번만 호출되며 다시 호출할 수 없다.

   ```jsx
   (function () {
     var a = 10;
     console.log(a);
     return a;
   })();
   ```

   - 즉시 실행 함수는 익명 함수로 선언하는 것이 일반적이다. 어차피 기명 함수로 작성해도 함수 선언문이 아니라 리터럴로 평가되어 호출할 수 없다.
   - 즉시 실행 함수를 보면 ( ) 그룹 연산자로 묶어 놓은 경우가 많은데, 그렇게 하는 이유는 함수를 함수 리터럴로 평가해서 함수 객체를 생성하기 위해서이다.
   - ❗즉, 다른 방법으로도 함수 객체를 생성할 수 있다면 가능 하다는 것 → ( ), !, + 등으로도 만들 수 있다. 그래도 그룹 연산자로 묶는 것이 일반적이다.

   ```jsx
   var res = (function () {
     var a = 3;
     var b = 5;
     return a * b;
   })();

   console.log(res);

   var res2 = (function (a, b) {
     return a * b;
   })(3, 5);

   console.log(res2);
   ```

   - 위 방법처럼 인수를 전달하는 것도 가능하다.

1. **재귀함수**

   - 자기 자신을 호출하는 함수
   - ❗ 함수 표현식으로 재귀 호출을 할 때, 식별자와 함수 이름 둘 다 가능하다! 함수 이름은 함수 몸체 내부에서 사용할 수 있기 때문! 물론 외부에서는 식별자로 호출해야 한다.

   ```jsx
   var factorial = function foo(n) {
     if (n <= 1) return 1;
     // return n * factorial(n - 1);
     return n * foo(n - 1); // 둘 다 가능하다.
   };

   console.log(factorial(5));
   ```

   - 반드시 재귀 호출을 멈출 수 있는 탈출 조건을 만들어야 한다.
   - 무한 반복에 빠지면 스택 오버플로 에러 발생 가능성이 있다. 주의해야 함. 한정적으로만 사용하는 것 권장.

1. **중첩 함수**

   - 함수 내부에 정의된 함수를 **중첩 함수** 또는 **내부 함수**라고 한다.
   - 중첩 함수를 포함하는 함수를 외부 함수라고 한다.
   - 보통 내부 함수는 외부 함수를 돕는 헬퍼 함수의 역할을 한다.
   - ❗ 함수 선언문의 경우 ES6 이전에는 코드의 최상위 또는 함수 내부에서만 정의할 수 있었으나 ES6 문법 이후로는 if 문이나 for 문 등 코드 블록에서 정의할 수 있다. → 단, 호이스팅 발생으로 인해 혼란이 발생할 수 있으므로 바람직하지 않다.
   - 중첩 함수는 **스코프**와 **클로저**와 깊은 관련이 있다.

1. **콜백 함수**

   - 🌟🌟🌟 **콜백함수: 함수의 매개변수를 통해 다른 함수의 내부로 전달되는 함수**
   - 🌟🌟🌟 **고차함수: 매개변수를 통해 함수의 외부에서 콜백 함수를 전달 받는 함수**
   - 함수의 반복하는 일이 공통적으로 수행하지만, 일부분이 매번 다르기 때문에 새롭게 정의해야 하는데 이를 공통 로직을 정의해두고 추상화하여, 함수 외부에서 내부로 전달하면 더욱 유연한 구조를 가질 수 있게 된다. 쉽게 말하자면 유연성과 재사용성을 높이는 느낌?
   - 고차 함수는 콜백 함수를 자신의 일부분으로 합성한다.
   - ❗ 고차함수는 함수를 호출하는게 아니라 함수 자체를 전달해야 한다!!! → 이러기 위해서는 인수가 맞아야 겠지요?
   - ⭐ 콜백 함수를 여러 곳에서 호출할 필요가 있거나 콜백 함수를 전달받는 함수가 자주 호출된다면, 함수 외부에서 콜백 함수를 정의한 후 함수 참조를 고차 함수에 전달하는 것이 효과적이다.
   - 콜백 함수는 정말 많이 쓰인다. 함수형 프로그래밍 패러다임 분만 아니라 이벤트 처리, AJAX 통신, 타이머 함수와 같은 비동기 처리에 모두 쓰임.
   - ❗ 배열 고차 함수에도 쓰임!! (우리가 흔히 사용하는 배열 고차함수에도 전부 적용되는 이야기이다. 우리가 흔히 쓰는 방식은 화살표 함수로 함수를 정의했던 방식이였던 것)

1. **순수 함수와 비순수 함수**

   - 사이드 이펙트가 없는 함수 → 순수 함수, 있는 함수 → 비순수 함수
   - 순수 함수는 동일한 인수가 전달되면 언!제!나! 동일한 값을 반환하는 함수. 내부 상태에만 의존한다고 하더라도 상태가 호출될 때마다 변화하면 순수 함수 아님! (여기서 외부 상태란. 전연 변수, 서버 데이터, 파일, Console,DOM 등이 있다.)
   - 비순수 함수는 외부 상태에 의존하거나 외부 상태를 변경하는 함수. 참조에 의한 전달 말고도 외부 상태를 변경할 수도 있다. (당연)

   ```jsx
   var count = 0;

   function increase() {
     return ++count;
   }
   increase();
   console.log(count); // 1
   increase();
   console.log(count); // 2
   ```

   - 지겹도록 말하고 있지만 함수가 외부 상태를 변경하면 추적이 어려워진다. 그래서 비순수함수는 최대한 줄이자는 것.

   ### 함수형 프로그래밍

   - 함수형 프로그래밍은 순수 함수와 보조 함수의 조합을 통해 외부 상태를 변경하는 부수 효과를 최소화하는 불변성을 지향하는 프로그래밍 패러다임이다.
   - 로직 내에서 반복문과 조건문을 제거하여 복잡성을 해결하고
   - 변수 사용을 억제하거나 생명주기를 최소화하여 상태 변경을 피해 오류를 최소화 하는 것이 목표이다.
   - 함수형 프로그래밍은 결국 순수 함수를 통해 부수 효과를 최대한 억제해 오류를 피하고 프로그래밍의 안정성을 높이려는 일환이라 볼 수 있다.
   - 자바스크립트는 멀티 패러다임 언어로서 객체 지향 프로그래밍과 함수형 프로그래밍을 적극적으로 활용하고 있다.
