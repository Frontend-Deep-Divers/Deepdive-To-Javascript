# 12장 함수

## 12.1 함수란?

함수는 자바스크립트의 핵심 개념과 밀접한 관련이 있다.

프로그래밍 언어의 함수는 일련의 과정을 문으로 구현하고 코드 블록으로 감써서 하나의 실행 단위로 정의한 것이다.

매개변수를 설정하고, 입력으로 인수를 받아 출력으로 반환값을 반환한다.

## 12.2 함수를 사용하는 이유

함수는 코드의 재사용을 가능하게 한다.

코드 중복을 줄이고 재사용성을 높이면 유지보수의 편의성을 높이고 실수를 줄여 코드의 신뢰성을 높일 수 있다.

이것이 함수의 존재 의의다.

## 12.3 함수 리터럴

```js
// 함수 리터럴을 변수에 할당
var func = function add(x, y) {
  return x + y;
};
```

자바스크립트의 **함수는 객체 타입의 값**이다.

따라서 함수 리터럴로 생성할 수 있다. 리터럴은 값을 생성하기 위한 표기법이다. 따라서 함수 리터럴도 평가되어 값을 생성하며, 이 값은 객체다. 즉, **함수는 객체다.**

일반 객체와는 다르게 **함수는 호출이 가능하다.** 그리고 객체에는 없는 함수 객체 고유의 프로퍼티를 갖는다.

자바스크립트에서 함수가 객체라는 사실은 다른 언어와 구별되는 특징이므로 이 특징을 잘 알고 있어야 한다.

## 12.4 함수 정의

자바스크립트의 함수 정의 방식에는 4가지가 있다.

- 함수 선언문

```js
function add(x, y) {
  return x + y;
}
```

- 함수 표현식

```js
var add = function (x, y) {
  return x + y;
};
```

- Funtion 생성자 함수

```js
var add = new Function("x", "y", "return x + y");
```

- 화살표 함수 (ES6)

```js
var add = (x, y) => x + y;
```

> 변수는 선언하지만, 함수는 정의한다고 표현한다. 함수 선언문이 평가되면 식별자가 암묵적으로 생성되고 함수 객체가 할당된다. ES 사양에서도 동일하게 표현하고 있다.

### 함수 선언문

함수 선언문은 함수 리터럴과 형태가 동일하다. 단, 함수 리터럴은 함수 이름을 생략할 수 있으나 **함수 선언문은 함수 이름을 생략할 수 없다.**

함수 선언문은 **표현식이 아닌 문**이다. 개발자 콘솔에서 실행 완료 시 `undefined`가 출력되는 것으로 확인할 수 있다.

때문에 함수 선언문은 변수에 할당할 수 없다.

```js
var add = function add(x, y) {
  return x + y;
};
```

위 코드를 보면 함수 선언문을 변수에 할당한 것처럼 보이지만, 실제로는 자바스크립트 엔진이 이를 **함수 리터럴 표현식으로 해석한 것**이다. 둘은 형태가 동일하기 때문이다.

함수 선언문이든 함수 리터럴 표현식이든 함수가 생성되는 것은 동일하다. 하지만 함수를 생성하는 내부 동작에 차이가 있다.

```js
function foo() {
  console.log("foo");
}
foo(); // foo

(function bar() {
  console.log("bar");
});

bar(); // ReferenceError: bar is not defined
```

그룹 연산자 내부의 함수 리터럴 `bar`는 함수 선언문으로 해석되지 않고 함수 리터럴 표현식으로 해석된다. 그룹 연산자의 피연산자는 값으로 평가될 수 있는 표현식이어야 한다. 때문에 표현식이 아닌 함수 선언문은 피연산자로 사용할 수 없다.

**기명 함수 리터럴은 코드의 문맥에 따라 함수 선언문 또는 함수 리터럴 표현식으로 해석된다.**

💡함수 선언문과 함수 리터럴 표현식은 함수 객체를 생성한다는 점에서 동일하지만, 함수 선언문은 호출할 수 있지만, 함수 리터럴 표현식은 호출할 수 없다. 함수 리터럴에서 **함수 이름은 함수 몸체 내에서만 참조할 수 있는 식별자기 때문이다.**

그렇다면 함수 선언문은 어떻게 함수 이름으로 호출할 수 있었을까?

자바스크립트 엔진은 **함수 선언문을 해석해 함수 이름과 동일한 이름의 식별자를 암묵적으로 생성하고, 거기에 함수 객체를 할당한다.**

함수 선언문을 의사 코드로 표현하면 아래 코드와 같다.

```js
var add = function add(x, y) {
  return x + y;
};

add(2, 3);
```

자바스크립트 엔진은 함수 선언문을 함수 표현식으로 변환해 함수 객체를 생성한다고 생각할 수 있지만, 둘은 정확히 동일하게 동작하지는 않는다.

> 💡함수 선언문과 함수 리터럴 표현식의 차이점
>
> - 함수 선언문은 호이스팅과 식별자 생성을 통해 선언보다 먼저 호출할 수 있는 반면, 함수 리터럴 표현식은 변수에 할당된 후에 호출할 수 있다.
>
>   - 호이스팅: 함수 선언문은 전체 함수가 호이스팅되지만, 함수 리터럴 표현식은 변수 선언만 호이스팅되고 할당은 호이스팅되지 않는다.
>   - 식별자 생성: 함수 선언문은 암묵적으로 식별자를 생성하여 외부에서 호출할 수 있지만, 함수 리터럴 표현식의 이름은 함수 내부에서만 참조할 수 있다.
>   - 호출 가능성: 함수 선언문은 선언보다 먼저 호출할 수 있지만, 함수 리터럴 표현식은 선언 후에 호출할 수 있다.

&nbsp;

### 함수 표현식

자바스크립트의 함수는 객체 타입의 값이다. 이는 값처럼 변수에 할당할 수도 있고 프로퍼티 값이 될 수도 있으며 배열의 요소가 될 수도 있다는 의미다.

이처럼 값의 성질을 갖는 객체를 **일급 객체**라 한다.

💡**자바스크립트의 함수는 일급 객체다.** 함수를 값처럼 쓸 수 있다는 것이다.

함수가 일급 객체라는 특성을 이용해 함수 리터럴로 생성한 함수 객체를 변수에 할당할 수 있다. 이러한 함수 정의 방식을 **함수 표현식**이라 한다.

```js
var add = function (x, y) {
  return x + y;
};
```

함수 리터럴의 함수 이름은 생략 가능하다. 이러한 함수를 **익명 함수**라 한다.

함수를 호출할 때는 함수 이름이 아닌 함수 식별자를 사용해야 한다. 함수 이름은 함수 몸체 내부에서만 유효한 식별자이므로 함수 이름으로 호출할 수 없다.

함수 선언문은 "표현식이 아닌 문"이고 함수 표현식은 "표현식인 문"임을 기억하자. 미묘한 차이가 있다.

&nbsp;

### 함수 생성 시점과 함수 호이스팅

함수 선언문으로 정의한 함수와 함수 표현식으로 정의한 함수의 생성 시점이 다르다.

함수 선언문도 런타임 이전에 자바스크립트 엔진에 의해 먼저 실행된다. 런타임 이전에 함수 객체가 먼저 생성되는 것이다.

💡**함수 선언문은 함수 호이스팅이 일어나고, 함수 표현식은 함수 호이스팅이 일어나지 않는다.**

함수 호이스팅과 변수 호이스팅은 미묘한 차이가 있다.

`var`의 변수 호이스팅은 `undefined`로 초기화되지만, 함수 선언문의 함수 호이스팅은 호출이 가능하다.

함수 표현식은 변수에 할당되는 값이 함수 리터럴인 문이다. 변수 선언이 먼저 `undefined`로 초기화되지만 **변수 할당문의 값은 할당문이 실행되는 시점, 즉 런타임에 평가되므로 함수 표현식의 함수 리터럴도 할당문이 실행되는 시점에 평가되어 함수 객체가 된다.**

💡따라서 **함수 표현식으로 함수를 정의하면 함수 호이스팅이 발생하는 것이 아니라 변수 호이스팅이 발생한다.**

&nbsp;

### Function 생성자 함수

`Function`이라는 빌트인 생성자 함수가 있다.

매개변수와 함수 몸체를 문자열로 전달하면서 `new` 연산자(없어도 결과는 동일하다.)와 함께 호출하면 함수 객체를 생성한다.

> 생성자 함수: 객체를 생성하는 함수

```js
var add = new Function("x", "y", "return x + y");
```

**바람직한 선언 방법이 아니며, 생성자 함수로 생성한 함수는 클로저를 생성하지 않고, 함수 선언문이나 함수 표현식과 다르게 동작한다.**

&nbsp;

### 화살표 함수

ES6에서 도입된 문법이다.

`function` 키워드 대신 `=>`를 사용해 함수를 선언한다. 항상 익명 함수로 정의한다.

```js
const add = (x, y) => x + y;
```

⚠️함수 표현식을 완전히 대체하기 위한 문법이 아니며, 내부 동작마저 간략화되어 있음에 유의한다.

- 생성자 함수로 사용할 수 없다.
- `this` 바인딩 방식이 다르다.
- `prototype` 프로퍼티가 없으며 `arguments` 객체를 생성하지 않는다.

## 12.5 함수 호출

**함수를 호출하면 현재의 실행 흐름을 중단하고 호출된 함수로 실행 흐름을 옮긴다.**

### 매개변수와 인수

함수가 호출되면 매개변수도 `undefined`로 초기화되며 인수가 순서대로 할당된다.

⚠️인수가 할당되지 않은 매개변수는 그대로 `undefined`가 되며, 에러가 발생하지 않음에 유의하자. 초과된 인수는 무시된다.

함수 실행 결과에는 영향을 주지 않지만 초과된 인수는 `arguments` 객체의 프로퍼티에 보관된다.

&nbsp;

### 인수 확인

1. 자바스크립트 함수는 매개변수와 인수의 개수가 일치하는지 확인하지 않는다.
2. 동적 언어기 때문에 매개변수 타입을 사전에 지정할 수 없다.

때문에 함수 내에서 적절한 인수가 전달되었는지 확인해줄 필요가 있다.

인수를 확인할 수 있는 방법은 다음과 같다.

1. 타입스크립트 이용
2. 단축 평가 이용
3. 매개변수 기본값 이용(⚠️매개변수에 인수를 전달하지 않은 경우와 `undefined`를 전달한 경우에만 유효)

&nbsp;

### 매개변수의 최대 개수

ES 사양에서는 매개변수 개수는 제한하고 있지 않다.

그럼 최대 몇개가 적당할까?

책에서는 3개가 넘지 않는 것을 권장한다. 만약 그 이상을 전달할 경우 하나의 매개변수를 선언하고 객체를 인수로 전달하는 것이 유리하다고 한다.

객체를 인수로 사용할 경우, **프로퍼티 키를 제대로 전달한다는 가정 하에 순서는 신경 쓰지 않아도 된다**.

⚠️하지만 함수 내부에서 객체를 변경했을 때 함수 외부의 객체가 변경되는 부수 효과를 주의해야 한다.

&nbsp;

### 반환문

- 반환문을 생략하면 `undefined`를 반환한다.
- `return`과 반환값으로 사용한 표현식 사이의 줄바꿈이 있으면 자동 세미콜론 삽입 기능에 의해 표현식이 무시된다.
- 브라우저에서는 `return` 문을 전역으로 사용할 수 없지만, Node.js 환경에서는 모듈 시스템에 의해 파일 별로 독립적인 파일 스코프를 가지기 때문에 사용 가능하다.

## 12.6 참조에 의한 전달과 외부 상태 변경

⚠️객체 타입을 매개변수로 받을 때는 외부 원본 객체가 변경될 수 있음에 유의해야 한다.

이를 위해 객체를 불변 객체로 만들어 사용할 수 있다. 깊은 복사를 통해 새로운 객체를 생성하고 재할당을 통해 교체는 식이다.

> 외부 상태를 변경하지 않고 외부 상태에 의존하지도 않는 함수를 순수 함수라 한다. 순수 함수를 통해 부수 효과를 최대한 억제하여 오류를 피하고 프로그램의 안전성을 높이는 프로그래밍 패러다임을 **함수형 프로그래밍**이라 한다.

## 12.7 다양한 함수의 형태

### 즉시 실행 함수

함수 정의와 동시에 즉시 호출되는 함수를 즉시 실행 함수(Immediately Invoked Function Expression, IIFE)라 한다.

즉시 실행 함수는 단 한번만 호출되며 다시 호출할 수 없다.

```js
// 익명 즉시 실행 함수
(function () {
  return "Hello";
})();
```

보통 익명 함수로 사용하는 것이 일반적인데, 어차피 한 번 실행하고 말 함수이기 때문에 호출을 위한 식별자도 필요없기 때문이다.

즉시 실행 함수로 만드려면 함수 리터럴을 평가해서 함수 객체를 생성해야 한다. 함수 객체를 생성하기 위한 많은 방법이 있겠지만, **함수를 그룹 연산자로 묶어 사용**하는 것이 일반적이다.

즉시 실행 함수도 일반 함수처럼 값을 반환할 수 있고 인수를 전달할 수도 있다.

💡즉시 실행 함수 내에 코드를 모아 두면 변수나 함수 이름의 충돌을 방지할 수 있다.

&nbsp;

### 중첩 함수

```js
function outer() {
  var a = 1;

  function inner() {
    var b = 2;
    console.log(a);
  }

  inner();
}

outer();
```

ES6부터 함수 정의는 어디든 가능하다. 함수 선언문은 ES6 이전에 코드 최상위나 다른 함수 내부에서만 정의할 수 있었으나, ES6부터는 `if` 문이나 `for` 문 등 코드 블록 내에서도 정의할 수 있다. 단 이런 방식은 호이스팅으로 인해 혼란을 발생시키므로, 바람직하지 않다.

&nbsp;

### 콜백 함수

함수 내부에서 다양한 일(함수)을 처리하고 싶을 때, 콜백 함수를 이용할 수 있다.

**함수의 매개변수를 통해 다른 함수 내부로 전달되는 함수를 콜백 함수라고 하며, 매개변수를 통해 함수의 외부에서 콜백 함수를 전달받은 함수를 고차 함수(High-Order Function, HOF)라고 한다.**

매개변수로 함수를 전달 받을 수 있고, 반환값으로 함수를 반환하는 함수를 함수형 프로그래밍에서 고차 함수라한다.

```js
function repeat(n, f) {
  for (var i = 0; i < n; i++) {
    f(i);
  }
}

repeat(5, function (i) {
  if (i % 2) console.log(i);
}); // 1 3
```

함수형 프로그래밍 패러다임과 비동기 처리(이벤트 처리, Ajax 통신, 타이머 함수 등)에 자주 활용된다.

또한, 배열 고차 함수(`map`, `filter`, `reduce`)에서도 사용된다.

&nbsp;

### 순수 함수와 비순수 함수

- 순수 함수: 부수 효과가 없는 함수
  - 오직 매개변수를 통해 동일한 인수에 의해 언제나 동일한 값을 반환한다.
  - 인수를 최소 하나 이상 가진다.
  - 인수를 변경하지 않는다(인수 불변성).
- 비순수 함수: 부수 효과가 있는 함수

> 부수 효과: 어떤 외부 상태에 의존하거나, 외부 상태를 변경하는 효과

```js
var count = 0;

// 동일한 인수에 대해 언제나 동일한 값을 반환
function pureFunction(n) {
  return ++n;
}

// 외부 상태에 의존하며 외부 상태를 변경
function impureFunction() {
  return ++n;
}
```

**함수가 외부 상태를 변경하면 상태 변화를 추적하기 어렵다. 때문에 순수 함수를 사용하는 것이 좋다.**

함수형 프로그래밍은 순수 함수와 보조 함수의 조합을 통해 외부 상태를 변경하는 부수 효과를 최소화해서 불변성을 지향하는 프로그래밍 패러다임이다. 조건문과 반복문을 제거해서 복잡성을 해결하며, 변수 사용을 억제하거나 생명주기를 최소화해서 상태 변경을 피해 오류를 최소화한다.

자바스크립트는 멀티 패러다임 언어이므로 함수형 프로그래밍을 적극적으로 활용하고 있다.
