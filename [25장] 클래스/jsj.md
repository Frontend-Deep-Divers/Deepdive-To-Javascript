# 25장 클래스

## 25.1 클래스는 프로토타입의 문법적 설탕인가?

- 자바 스크립트는 프로토타입 기반 객체지향 언어로 클래스가 필요없긴 하다.
- 기존의 클래스 기반 언어에 익숙한 사용자들을 위해 ES6부터 도입되어 클래스 기반 객체지향 프로그래밍 언어와 매우 흡사한 새로운 객체 생성 메커니즘을 제시한다.
- 하지만 사실 클래스는 새로운 객체지향 모델을 제공하는 것이 아니라 함수로, 기존 프로토타입 기반 패턴을 클래스 기반 패턴처럼 사용할 수 있도록 하는 문법적 설탕이라고 볼 수도 있다.
- 클래스와 생성자 함수간의 차이
    - 클래스를 new 연산자 없이 호출하면 에러가 발생한다. 하지만 생성자 함수를 new 연산자 없이 호출하면 일반 함수로서 호출된다.
    - 클래스는 상속을 지원하는 extends와 super 키워드를 제공한다. 하지만 생성자 함수는 그렇지 않다.
    - 클래스는 호이스팅이 발생하지 않는 것처럼 동작한다. 하지만 함수 선언문으로 정의된 생성자 함수는 함수 호이스팅이, 함수 표현식으로 정의한 생성자 함수는 변수 호이스팅이 발생한다.
    - 클래스 내의 모든 코드에는 암묵적으로 strict mode가 지정되어 실행되며 strict mode를 해제할 수 없다. 하지만 생성자 함수는 암묵적으로 strict mode가 지정되지 않는다.
    - 클래스의 constructor, 프로토타입 메서드, 정적 메서드는 모두 프로퍼티 어트리뷰트 `[[Enumerable]]` 의 값이 false다. 열거되지 않는다는 것이다.
- **새로운 객체 생성 메커니즘**이라고 보는 것이 좀 더 합당하다.

> ❓**문법적 설탕**
> 
> - 사람이 이해 하고 표현하기 쉽게 디자인된 프로그래밍 언어 문법
> - 더욱 더 간결하고 명확하게 표현이 가능한 문법을 뜻한다.

 

## 25.2 클래스 정의

- 클래스는 표현식으로 정의되며 이는 클래스가 값으로 사용할 수 있는 일급 객체라는 것이다. 이로써 다음과 같은 특징을 갖는다.
    - 무명의 리터럴로 생성할 수 있다. (런타임에 생성 가능)
    - 변수나 자료구조에 할당이 가능하다.
    - 함수의 매개변수에 전달할 수 있다.
    - 함수의 반환값으로 사용할 수 있다.
- 클래스는 함수이며 값처럼 사용할 수 있는 일급 객체다.
- 클래스와 생성자 함수의 정의 방식은 형태적인 면에서 매우 유사하다.
    
    ![image.png](25%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%8F%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A2%E1%84%89%E1%85%B3%201c6f78a2bff18066a183e3587d553bb8/image.png)
    

## 25.3 클래스 호이스팅

- 클래스는 함수로 평가된다. 일반적인 함수 선언처럼 런타임 이전에 평가되어 함수 객체를 생성하고 프로토타입 또한 더불어 생성된다. 단, 클래스는 클래스 정의 이전에 참조할 수 없다.
- 호이스팅이 발생하기는 하나 let, const 키워드 처럼 TDZ에 빠지기에 호이스팅이 발생하지 않는 것처럼 동작한다. (모든 선언문은 런타임 이전에 먼저 실행되기 때문)

## 25.4 인스턴스 생성

- 클래스는 생성자 함수이며 new 연산자와 함께 호출되어 인스턴스를 생성한다.
- 함수는 일반함수나 생성자 함수로 호출될 수 있지만 클래스는 인스턴스 생성용으로만 존재하므로 반드시 new 연산자와 함께 호출해야한다.
    
    ```jsx
    class Person {}
    //인스턴스 생성
    const me = new Person();
    console.log(me); //Person{}
    ```
    
- 클래스 표현식에서 사용한 클래스 이름은 함수이름과 마찬가지로 외부 코드에서는 접근 불가능하다.
    
    ```jsx
    const Person = class MyClass {};
    
    const me = new Person();
    
    console.log(MyClass); //ReferenceError
    ```
    

## 25.5 메서드

- 클래스 몸체에는 constructor, 프로토타입 메서드, 정적 메서드를 선언할 수 있다.
- constructor
    - 인스턴스를 생성하고 초기화하기 위한 특수한 메서드
    - 이름을 변경할 수 없다.
    - 모든 함수 객체가 가지고 있는 prototype 프로퍼티가 가리키는 프로토타입 객체의 constructor 프로퍼티는 클래스 자신을 가리키고 있다. 이는 **클래스가 인스턴스를 생성하는 생성자 함수**라는 것을 의미한다.
    - 클래스 몸체에 정의한 constructor의 경우 단순한 메서드로 해석되는 것이 아니라 클래스가 평가되어 생성한 함수 객체 코드의 일부가 된다. 클래스 정의가 평가되면 constructor의 기술된 동작을 하는 함수 객체가 생성된다는 것이다.
    - constructor와 생성자 함수의 차이
        - constructor는 클래스 내에 최대 한 개만 존재할 수 있다.
        - constructor를 생략하면 클래스에 빈 constructor가 암묵적으로 정의된다.
        - (이 이후로 좀더 공부하기)
- 프로토타입 메서드
    - 클래스 몸체에서 정의한 메서드는 생성자 함수에 의한 객체 생성 방식과는 다르게 클래스의 prototype 프로퍼티에 메서드를 추가하지 않아도 기본적으로 프로토타입 메서드가 된다.
    - 생성자 함수와 마찬가지로 클래스가 생성한 인스턴스는 프로토타입 체인의 일원이 된다.
- 정적 메서드
    - 클래스에서는 메서드에 static 키워드를 붙이면 정적 메서드가 된다.
- 정적 메서드와 프로토타입 메서드의 차이
    - 서로 속해있는 프로토타입 체인이 다르다
    - 정적 메서드는 클래스로 호출, 프로토타입 메서드는 인스턴스로 호출한다.
    - 정적 메서드는 인스턴스 프로퍼티를 참조할 수 없지만, 프로토타입 메서드는 인스턴스 프로퍼티를 참조할 수 있다.
- 클래스에서 정의한 메서드의 특징
    - function 키워드를 생략한 메서드 축약 표현을 사용한다.
    - 객체 리터럴과는 다르게 클래스에 메서드를 정의할 때는 콤마가 필요없다.
    - 암묵적으로 strict mode로 실행된다.
    - for …in 문이나 Object.keys 메서드 등으로 열거할 수 없다. 즉, 프로퍼티의 열거 가능 여부를 나타내며, 불리언 값을 갖는 프로퍼티 어트리뷰트 [[Enumberable]]의 값이 false다.
    - 내부 메서드 [[Construct]]를 갖지 않는 non-constructor다. 따라서 new 연산자와 함께 호출할 수 없다.

## 25.6 클래스의 인스턴스 생성 과정

- 인스턴스 생성과 this 바인딩
    - new 연산자와 함께 클래스를 호출하면 constructor의 내부 코드가 실행되기 전 암묵적으로 빈 객체가 생성된다. 이 빈 객체가 바로 클래스가 생성한 인스턴스다.
    - 이때 클래스가 생성한 인스턴스의 프로토타입으로 클래스의 prototype 프로퍼티가 가리키는 객체가 설정된다. 그리고 암묵적으로 생성된 빈 객체 (인스턴스)는 this에 바인딩된다.
    - this는 클래스가 생성한 인스턴스를 가리키게 된다.
- 인스턴스 초기화
    - constructor의 내부 코드가 실행되어 this에 바인딩되어 있는 인스턴스를 초기화한다. 즉, this에 바인딩되어 있는 인스턴스에 프로퍼티를 추가하고 constructor가 인수로 전달받은 초기값으로 인스턴스의 프로퍼티 값을 초기화한다. (constructor생략시 이 과정도 생략됨)
- 인스턴스 반환
    - 클래스의 모든 처리가 끝나면 완성된 인스턴스가 바인딩된 this를 암묵적으로 반환한다.

## 25.7 프로퍼티

- 인스턴스 프로퍼티
    - 인스턴스 프로퍼티는 constructor 내부에서 정의해야한다.
    - constructor 내부의 this에 이미 객체가 바인딩되어 있기 때문에 this에 인스턴스 프로퍼티를 추가하는 형식으로 정의한다.
    - 이로써 클래스가 암묵적으로 생성한 빈 객체인 인스턴스에 프로퍼티가 추가되어 인스턴스가 초기화 된다.
- 접근자 프로퍼티
    - 다른 데이터 프로퍼티의 값을 읽거나 저장할 때 사용하는 접근자 함수 (getter, setter)로 구성된 프로퍼티다.
    - 클래스의 메서드는 기본적으로 프로토타입 메서드가 되므로 클래스의 접근자 프로퍼티 또한 인스턴스 프로퍼티가 아닌 프로토타입의 프로퍼티가 된다.
- 클래스 필드 정의 제안
    - 클래스 필드
        - 클래스 기반 객체지향 언어에서 클래스가 생성할 인스턴스의 프로퍼티를 가리키는 용어
        - ~~자바 스크립트의 클래스 몸체에는 메서드만 선언할 수 있기에 클래스 몸체에 자바처럼 클래스 필드를 선언하면 문법 에러가 발생한다.~~
            
            ```jsx
            class Person{
            	name = 'Lee'; 
            }
            
            const me = new Person('Lee');
            ```
            
        - ~~하지만 이 예제는 최신 브라우저나 Node.js 환경에서는 정상 동작하는데, 자바 스크립트에도 인스턴스 프로퍼티를 마치 클래스 기반 객체지향 언어의 클래스 필드처럼 정의할 수 있는 새로운 표준 사양이 제안되어 있기 때문이다. 허나, 이는 아직 ECMAScript 표준 사양으로 승급되지 않았다.. 최신 브라우저와 Node.js가 미리 이 제안을 선제적으로 구현해두었다.~~
        - ES12에 정식적으로 도입되었다.. 내가 보고 있는 책 버전의 8개월 뒤의 일이다.
        - 클래스 몸체에서 클래스 필드를 정의하는 경우 this에 클래스 필드를 바인딩해서는 안된다. this는 클래스의 constructor와 메서드 내에서만 유효하기 때문이다.
        - 클래스 필드에 초기값을 할당하지 않으면 undefined를 갖는다.
        - 인스턴스를 생성할 때 외부의 초기값으로 클래스 필드를 초기화할 필요가 있다면 constructor에서 클래스 필드를 초기화해야 한다.
        - 함수는 일급객체이므로 함수를 클래스 필드에 할당할 수 있으며 클래스 필드를 통해 메서드를 정의할 수도 있다. 허나 이 경우 해당 함수는 프로토타입 메서드가 아닌 인스턴스 메서드가 된다. 모든 클래스 필드는 인스턴스 프로퍼티가 되기 때문이며, 클래스 필드에 함수를 할당하는 것은 권장하지 않는다.
- private 필드 정의 제안
    - 자바 스크립트는 캡슐화를 완전하게 지원하지 않으며, 클래스 또한 private, public, protected 같은 접근 제한자를 지원하지 않는다. 인스턴스 프로퍼티는 인스턴스를 통해 클래스 외부에서 언제나 참조할 수 있다. (언제나 public)
    - 현재는 private필드를 정의할 수 있는 새로운 표준 사양이 제안되어 있다. private 필드의 선두에 #을 붙여줘야 하며 해당 필드를 참조할 때도 #을 붙여주어야 한다.
    - 이를 통해 클래스 내부에서만 참조가 가능하며, 클래스 외부에서는 접근자 프로퍼티를 통해서 간접적으로만 접근이 가능하다.
    - private 필드는 반드시 클래스 몸체에 정의해야한다.
- static 필드 정의 제안
    - static 키워드를 사용한 정적 메서드 정의 + static public/private 필드가 제안되어 구현되어 있따.

## 25.8 상속에 의한 클래스 확장

- 클래스 상속과 생성자 함수 상속
    - **상속에 의한 클래스 확장은 기존 클래스를 상속받아 새로운 클래스를 확장하여 정의**하는 것이다.
    - 클래스와 생성자 함수는 인스턴스를 생성할 수 있는 함수라는 점에서 매우 유사하나, 클래스는 상속을 통해 기존 클래스를 확장할 수 있는 문법이 제공되나 생성자 함수는 그렇지 않다.
- extends 키워드
    - 상속을 통해 클래스를 확장하려면 extends 키워드를 사용하여 상속받을 클래스를 정의한다.
    - 서브 클래스 : 상속을 통해 확장된 클래스
    - 수퍼 클래스 : 서브 클래스에 상속된 클래스
    - extends 키워드의 역할은 수퍼 클래스와 서브 클래스 간의 상속 관계를 설정하는 것이다.
    - 수퍼 클래스와 서브 클래스는 인스턴스의 프로토타입 체인뿐만 아니라 클래스 간의 프로토타입 체인도 생성한다. 이를 통해 프로토타입 메서드, 정적 메서드 또한 상속이 가능하다.
- 동적 상속
    - extends 키워드는 클래스뿐만 아니라 생성자 함수를 상속받아 클래스를 확장할 수 도 있다.
- 서브 클래스의 constructor
    - 서브 클래스에서 constructor을 생략하면 클래스에 다음과 같은 constructor가 암묵적으로 정의된다.
        
        ```jsx
        constructor(...args) { super(...args); } 
        //args는 new연산자와 함께 클래스를 호출할 때 전달한 인수의 리스트다.
        ```
        
- super 키워드
    - 함수처럼 호출할 수도 있고 this와 같이 식별자처럼 참조할 수 있는 특수한 키워드
    - super의 동작은 다음과 같이 동작한다
        - super를 호출하면 수퍼 클래스의 constructor(super-constructor)를 호출한다.
        - super를 참조하면 수퍼 클래스의 메서드를 호출할 수 있다.
    - super 호출
        - **super를 호출하면 수퍼클래스의 constructor(super-constructor)를 호출한다.**
        - super를 호출할 때 주의할 사항
            - 서브 클래스에서 constructor를 생략하지 않는 경우 서브 클래스의 constructor에는 반드시 super를 호출해야한다.
            - 서브 클래스의 constructor에서 super를 호출하기 전에는 this를 참조할 수 없다.
            - super는 반드시 서브 클래스의 constructor에서만 호출한다. 서브 클래스가 아닌 클래스의 constructor나 함수에서 super를 호출하면 에러가 발생한다.
    - super 참조
        - **메서드 내에서 super를 참조하면 수퍼 클래스의 메서드를 호출할 수 있다.**
- 상속 클래스의 인스턴스 생성 과정
    - 서브 클래스의 super 호출
    - 수퍼 클래스의 인스턴스 생성과 this 바인딩
    - 수퍼 클래스의 인스턴스 초기화
    - 서브 클래스 constructor로의 복귀와 this 바인딩
    - 서브 클래스의 인스턴스 초기화
    - 인스턴스 반환