# 문법적 설탕

자바스크립트는 클래스가 필요 없는 객체지향 언어로 생성자 함수와 프로토타입을 통해 상속을 구현할 수 있음

ES6에서 클래스가 도입되었지만, 프로토타입 기반 패턴을 클래스 기반 패턴처럼 사용할 수 있도록 하는 문법적 설탕으로 볼 수 있음

하지만 몇 가지 차이가 있음

1. 클래스를 new 연산자 없이 호출하면 에러 발생
2. extends, super 키워드 지원
3. 호이스팅이 발생하지 않는 것처럼 동작
4. 클래스 내의 모든 코드는 암묵적으로 strict mode가 적용됨
5. 클래스의 constructor, 프로토타입 메서드, 정적 메서드는 모두 [[Enumerable]] 이 `false`

따라서 새로운 객체 생성 메커니즘으로 볼 수 있음

# 클래스 정의

```jsx
class Person {}

// 클래스를 표현식으로 정의할 수 있음 -> 클래스도 일급 객체
const Person = class {}
const Person = class MyClass {}
```

클래스에는 메서드만 정의할 수 있음

```jsx
class Person {
	constructor() {}
	
	sayHi() {}
	
	static sayHello() {}
}
```

# 클래스 호이스팅

클래스는 함수로 평가됨

클래스 선언문으로 정의한 클래스는 코드 평가 단계에서 평가되어 함수 객체를 생성함(`constructor`) → 프로토타입도 생성됨

하지만 클래스 정의 이전에 참조할 수는 없음  → TDZ 형성

# 인스턴스 생성

```jsx
const me = new Person(); // 반드시 new 연산자와 함께 호출
```

```jsx
const Person = class MyClass {}

// ReferenceError
// 클래스 표현식에서 사용한 클래스 이름은 외부 코드에서 접근 불가
const me = new MyClass();
```

# 메서드

### `constructor`

인스턴스를 생성하고 초기화하기 위한 특수한 메서드

클래스가 정의되면 `constructor` 의 기술된 동작을 하는 함수 객체가 생성됨

생성자 함수와 차이가 있음

1. 클래스 내에 최대 한 개만 존재할 수 있음
2. 생략하면 빈 `constructor` 가 암묵적으로 정의됨

### 프로토타입 메서드

클래스 몸체에서 정의한 메서드는 인스턴스 프로토타입에 존재하는 프로토타입 메서드가 됨

### 정적 메서드

`static` 키워드를 붙여서 정적 메서드를 생성함

### 클래스에서 정의한 메서드의 특징

1. `function` 키워드를 생략한 메서드 축약 표현을 사용함
2. 클래스에 메서드를 정의할 때는 콤마가 필요 없다
3. 암묵적 strict mode 적용
4. 메서드를 열거할 수 없음
5. non-constructor
