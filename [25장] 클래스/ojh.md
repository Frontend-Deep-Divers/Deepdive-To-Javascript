# 25.1 클래스는 프로토타입의 문법적 설탕인가?

---

- 자바스크립트는 프로토타입 기반 객체지향 언어입니다. 비록 다른 객체지향 언어와 차이점은 있지만
- ES5 까지 클래스 없이도 프로토타입을 통해 객체지향 언어의 상속을 구현할 수 있다.

![image.png](attachment:a6460d54-adbb-470e-9771-200c907d87e9:image.png)

- 하지만 클래스 기반 언어에 익숙한 프로그래머들에게는 장벽같은 존재 → 그래서 ES6 에 클래스가 도입됨. → 기존 클래스 기반 객체지향 프로그래밍 언어와 매우 흡사하다.
- **❗ 하지만 클래스도 결국 함수이면 클래스 기반 패턴처럼 사용할 수 있게 만들어준 문법적 설탕이다. → 단 둘 다 프로토타입 기반 인스턴스를 생성하지만, 정확히 동일하게 동작하지는 않는다. ← 클래스는 생성자 함수보다 엄격! 하며 생성자 함수에서 제공하지 않는 기능도 제공한다.**
- 유사하지만 차이가 있다.
  ![image.png](attachment:93d4606a-f57a-4db3-9092-4481765ad873:image.png)
- 생성자 함수와 클래스는 프로토타입 기반의 객체지향을 구현했다는 점에서 매우 유사하다. 하지만 더욱 격고하다. → 특히 extends , super 를 통한 상속
- 문법적 설탕보다는 **새로운 객체 생성 메커니즘**

# 25.2 클래스 정의

---

- class 키워드 → 일반적으로 파스칼 케이스 사용안해도 에러는 아님
- 일반적이지 않지만 표현식으로도 정의는 가능하다. 무형 클래스 가능. → 가능한 근거는 클래스도 일급 객체이기 때문이다.
  - 무명의 리터럴로 생성 가능. 런타임에 생성 가능
  - 변수나 자료구조에 저장 가능
  - 함수의 매개변수에 전달 가능
  - 함수의 반환값으로 사용 가능
- ❗**클래스 몸체에서 정의할 수 있는 메서드는 생성자, 프로토타입 메서드, 정적 메서드 3가지가 있다.**
- 클래스와 생성자 함수의 정의 방식 비교.

![image.png](attachment:4042acec-fba6-48df-8f95-b78e89d31f2f:image.png)

# 25.3 클래스 호이스팅

---

- 클래스는 함수로 평가된다.
- 생성자 함수로서 런타임 이전에 평가되어 함수 객체를 생성하고 프로토 타입도 생성한다.
- **❗단, 클래스 정의 이전에 참조할 수 없다.**
- 마치 호이스팅이 발생하지 않은 것처럼 보이지만 발생한다.
- let, const 키워드 처럼 호이스팅은 되지만 TDZ 일시적 사각지대에 빠지기 때문에 호이스팅 발생하지 않는 것처럼 동작한다.

![image.png](attachment:4e4e100d-692a-4153-8020-37fc404f326b:image.png)

- 모든 식별자는 호이스팅 된다. 선언문은 런타임 이전에 실행되기 때문

# 25.4 인스턴스 생성

- new 연산자와 함께 인스턴스를 생성한다.
- 반드시 함께 호출되어야 한다.

![image.png](attachment:31690141-361f-4d06-a85e-5f3cb0d080e1:image.png)

- 그렇지 않으면 에러 발생한다.
- 함수와 동일하게 클래스 표현식을 사용하면 클래스 이름이 아니라 식별자로 생성해야 한다.

![image.png](attachment:9307d093-066b-4312-9e17-e19bec2831d9:image.png)

# 25.5 메서드

---

- 메서드만 선언할 수 있다. 생성자, 프로토타입 메서드, 정적 메서드
- 클래스에 대한 새로운 제안 사항.
  - 원래는 반드시 contructor 내부에서 정의해야 하지만, 직접 정의할 수 있는 표준 사항이 제안되었다. → 이거 써본거 같음.

1. **constructor**

   - 인스턴스를 생성하고 초기화하기 위한 특수 메서드다.

   ![image.png](attachment:728558f7-317f-410a-8e1f-1863ff8c3515:image.png)

   - 한번 개발자 도구로 봐보자.

   ![image.png](attachment:e2ca52a1-f053-4bdb-a7bb-d19e47d9f2a8:image.png)

   - 클래스는 평가되어 함수 객체가 된다. 함수 고유의 프로퍼티를 모두 가지고 있다. 자신의 스코프 체인을 구성한다.
   - contructor 프로퍼티는 클래스 자신을 가르킨다. → 클래스가 인스턴스를 생성하는 생성자 함수라는 뜻

   ![image.png](attachment:9f3d9957-4c94-41b9-9c86-9eb80c8f891f:image.png)

   - 인스턴스 생성

   ![image.png](attachment:eed91b2a-c5b0-4bc8-b08b-b889cdddf09c:image.png)

   - ❓흥미로운 것은 클래스가 평가되어 생성된 함수 객체나 클래스가 생성한 인스턴스 어디에도 contructor 메서드가 보이지 않는다는 것이다. → 이는 클래스 몸체에 정의한 constructor 가 단순한 메서드가 아니라는 뜻.
   - constructor 는 메서드로 해석되는 것이 아니라 클래스가 평가되어 생성한 함수 객체 코드의 일부가 된다. 다시 말해 클래스 정의가 평가되면 constructor 기술된 동작을 하는 함수 객체가 생성된다.
   - ❗클래스의 constructor 메서드와 프로토타입의 constructor 프로퍼티는 이름이 같아 혼동하기 쉽지만 직접적인 연관은 없다. 프로토타입의 constructor 프로퍼티는 모든 프로토타입이 가지고, 생성자 함수를 가르킨다.
   - 생성자 함수와 유사하지만 몇 가지 차이가 있다.
   - ❗**클래스 내에서 최대 1개**

   ![image.png](attachment:3fa7ab76-f7aa-4e54-bbdd-a2d41e0907f2:image.png)

   - ❗**생략 가능**

   ![image.png](attachment:60648091-d218-4ae9-a6db-4cdc78f8b40f:image.png)

   - 고정값으로 인스턴스 초기화 하던, 인수로 인스턴스 초기화 하던 초기화 하려면 생략하면 안된다.
   - **생성자 함수와 동일하게 명시적으로 this 를 반환하면 인스턴스가 반환되지 못한다.**
     - 객체로 반환시, 명시적 반환
     - 원시값인 경우에는 무시하고 this 반환
   - ❗**constructor 내부에서 return 문은 반드시 생략해야 한다.**

1. **프로토타입 메서드**

   - 생성자 함수를 사용한 인스턴스 생성은 명시적으로 프로토 타입 메서드를 추가해줘야 한다.

   ![image.png](attachment:2391f19b-1401-419e-ab41-df0e6de8d658:image.png)

   - 클래스는 명시적으로 prototype 프로퍼티에 추가하지 않아도 기본적으로 프로토타입 메서드가 된다.

   ![image.png](attachment:a24076a9-4c66-42fc-96ee-7dc3010b52e2:image.png)

   - 생성자 함수와 마찬가지로 클래스가 생성한 인스턴스는 프로토타입 체인의 일원이 된다.

   ![image.png](attachment:4edbdaff-8dac-45a7-a29d-613266d2c117:image.png)

   ![image.png](attachment:7a5988f8-c445-4112-bce3-0fefcb0bdc2d:image.png)

   - 그렇기에 인스턴스는 프로토타입 메서드를 상속받아 사용할 수 있다.
   - 프로토타입 체인은 기존의 모든 객체 생성 방식뿐만 아니라 클래스에 의해 생성된 인스턴스에도 동일하게 적용된다.
   - 결국 클래스는 생성자 함수와 마찬가지로 프로토타입 기반의 객체 생성 방식이다.

1. **정적 메서드**

   - 정적 메서드란 인스턴스를 생성하지 않아도 호출할 수 있는 메서드이다.

   ![image.png](attachment:64e0f5cf-4548-4ab0-b823-535a4c41d61d:image.png)

   - class 에서는 static 키워드 붙이면 됨.

   ![image.png](attachment:7991092c-cc1c-44ef-84bd-8b590909b207:image.png)

   - 다음과 같은 프로토타입 체인

   ![image.png](attachment:93eff88a-011c-4350-a11c-0cf7fb13a793:image.png)

   - 클래스는 클래스 정의가 평가되는 시점에 함수 객체가 생성되므로, ❗ 정적 메서드는 클래스 정의 이후에 인스턴스를 생성하지 않아도 호출할 수 있다. ⇒ 클래스로 호출한다.
   - 당연히 인스턴스로는 호출 못한다. 프로토타입 체인상에 없지 않느냐.

   ![image.png](attachment:ff2a3184-b370-47b9-a257-d855d7735b09:image.png)

   ![image.png](attachment:162f9751-4cc9-41a3-aa1f-69b21f4f2c18:image.png)

1. **정적 메서드와 프로토타입 메서드의 차이**

   - 정적 메서드와 프로토 타입 메서드의 차이
     1. 자신이 속한 프로토타입 체인이 다르다.
     2. 정적 메서드는 클래스로, 프로토타입 메서드는 인스턴스로 호출
     3. 정적 메서드는 인스턴스 참조 불가능, 프로토타입 메서드는 참조 가능.

   ![image.png](attachment:ff91e845-71ba-4a52-90fb-93991b77779e:image.png)

   - 위 메서드는 인스턴스 참조 안한다. 인스턴스 참조해야 하면 아래처럼.

   ![image.png](attachment:2c30973c-035d-44c1-9a34-07ab5bac3d9a:image.png)

   - 정적 메서드는 클래스를 호출해야 하기에 this 는 클래스이고, 프로토타입은 this 가 인스턴스다. → 즉, 내부의 this 바인딩이 다르다.
   - 🌟 물론 메서드 내부에서 this 를 사용하지 않더라도 프로토타입 메서드로 정의할 수 있다. 하지만 반드시 인스턴스를 생성하고 호출해야 하므로 → this 사용 안하면 정적 메서드로 정의하자.
   - 표준 빌트인 객체의 정적 메서드는 유틸리티 함수다.

   ![image.png](attachment:666b7c4b-f5c9-4c25-b811-6efddc969a11:image.png)

   - **이처럼 클래스 또는 생성자 함수를 하나의 네임스페이스로 사용하여 정적 메서드를 모아 놓으면 이름 충돌 가능성을 줄여주고 관련 함수들을 구조화하는 효과가 있다.**
   - 정적 메서드는 애플리케이션 전역에서 사용할 유틸리티 함수를 전역 함수로 정의 않고 메서드로 구조화 할 때 유리한다.

   ![image.png](attachment:d76700c1-6968-4dea-91f3-b5fa1384e665:image.png)

1. **클래스에서 정의한 메서드 특징**
   1. function 키워드를 생략한 축약 표현을 사용한다.
   2. 객체 리터럴과 다르게 클래스 생성할 때는 콤마 필요 X
   3. 암묵저으로 strict mode 로 실행된다.
   4. for … in 등으로 열거할 수 없다. [[Enumerable]] 이 false 이다.
   5. 내부 메서드 [[Construct]] 를 가지지 않는 non-constructor 이다. new 와 함께 호출할 수 없다.
