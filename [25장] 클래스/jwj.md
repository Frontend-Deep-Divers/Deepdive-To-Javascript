# 25장 클래스

## 25.1 클래스는 프로토타입의 문법적 설탕인가?

ES6에서 도입된 클래스는 기존의 자바와 C#과 같은 클래스 기반 객체지향 프로그래밍에 익숙한 개발자를 위한 객체 생성 메커니즘이다.

자바스크립트에서는 클래스 또한 함수이며 기존 프로토타입 기반 패턴을 클래스 기반 패턴처럼 사용할 수 있게 해주는 문법적 설탕이라고 볼 수도 있다.

단, 클래스와 생성자 함수는 모두 프로토타입 기반의 인스턴스를 생성하지만 정확히 동일하게 동작하지는 않는다. 클래스는 생성자 함수보다 엄격하며 생성자 함수에서는 제공하지 않는 기능도 제공한다.

| 구분              | 클래스 (Class)                                                | 생성자 함수 (Constructor Function)    |
| ----------------- | ------------------------------------------------------------- | ------------------------------------- |
| 1. 호출 방식      | `new` 없이 호출하면 에러 발생                                 | `new` 없이도 일반 함수처럼 호출 가능  |
| 2. 상속           | `extends`, `super` 키워드 지원                                | `extends`, `super` 키워드 미지원      |
| 3. 호이스팅       | 호이스팅이 발생하지 않는 것처럼 동작                          | 함수 선언문으로 정의 시 호이스팅 발생 |
| 4. strict mode    | 암묵적으로 `strict mode` 적용됨 (해제 불가)                   | 기본적으로 적용되지 않음              |
| 5. 열거 가능 여부 | `constructor`, 프로토타입 메서드, 정적 메서드가 열거되지 않음 | 열거될 수 있음                        |

## 25.2 클래스 정의

```js
class Person {}
```

일반적이지는 않지만 표현식으로도 클래스를 정의할 수 있다. 익명으로도, 기명으로도 가능하다.

```js
// 익명 클래스 표현식
const Person = class {};

// 기명 클래스 표현식
const Person = class MyClass {};
```

클래스가 표현식으로 정의될 수 있다는 것은 클래스도 일급 객체라는 것을 의미한다.

클래스 몸체에는 0개 이상의 메서드만 정의할 수 있다. 클래스 몸체에서 정의할 수 있는 메서드는 `constructor`(생성자), 프로토타입 메서드, 정적 메서드 세 가지가 있다.

```js
// 클래스 선언문
class Person {
  // 생성자
  constructor(name) {
    // 인스턴스 생성 및 초기화
    this.name = name; // name 프로퍼티는 public하다.
  }

  // 프로토타입 메서드
  sayHi() {
    console.log(`Hi! My name is ${this.name}`);
  }

  // 정적 메서드
  static sayHello() {
    console.log("Hello!");
  }
}

// 인스턴스 생성
const me = new Person("Lee");

// 인스턴스의 프로퍼티 참조
console.log(me.name); // Lee
// 프로토타입 메서드 호출
me.sayHi(); // Hi! My name is Lee
// 정적 메서드 호출
Person.sayHello(); // Hello!
```

## 25.3 클래스 호이스팅

클래스는 함수로 평가된다.

때문에 클래스 선언문으로 선언한 클래스는 함수 선언문과 같이 소스코드 평가, 즉 런타임 이전에 먼저 평가되어 함수 객체를 생성한다. 이때 클래스가 평가되어 생성된 함수 객체는 생성자 함수로서 호출할 수 있는 함수, 즉 `constructor`다.

이떄 프로토타입도 같이 생성된다. 생성자 함수와 프로토타입은 단독으로 존재할 수 없고 언제나 쌍으로 존재하기 때문이다.

단, 클래스는 클래스 정의 이전에 참조하려고 하면 에러가 발생한다.

클래스 선언문도 호이스팅이 발생한다. 단 `let`과 `const` 키워드의 변수처럼 호이스팅된다. (TDZ에 빠질 수 있다.)

💡`var`, `let`, `const`, `function`, `function*`, `class` 키워드를 사용하여 선언된 모든 식별자는 호이스팅된다. 모든 선언문은 런타임 이전에 먼저 실행되기 때문이다.

## 25.4 인스턴스 생성

반드시 `new` 연산자와 함께 생성한다.

클래스 표현식으로 정의된 클래스는 클래스를 가리키는 식별자를 사용해야 한다. 클래스 이름을 사용해 인스턴스를 생성할 수 없다. (함수 표현식과 동일하게 동작한다.)

## 25.5 메서드

클래스 몸체에는 0개 이상의 메서드만 정의할 수 있다.

> ES2020에 따르면 인스턴스 프로퍼티는 반드시 `constructor` 내부에서 정의해야 했으나, 클래스 몸체에 메서드뿐만이 아니라 프로퍼티를 직접 정의할 수 있는 새로운 표준 사양이 제안되어 있다.

### `constructor`

`constructor`는 인스턴스를 생성하고 초기화하기 위한 특수한 메서드다. `constructor`는 이름을 변경할 수 없다.

`constructor`는 인스턴스 내부에 보이지 않는데, 이는 `constructor`는 메서드로 해석되지 않고 클래스가 평가되어 생성한 함수 객체 코드의 일부가 되기 때문이다. 즉, 클래스 정의가 평가되면 `constructor`의 기술된 동작을 하는 함수 객체가 생성된다는 것이다.

> ⚠️클래스의 `constructor` 메서드와 프로토타입의 `constructor` 프로퍼티는 직접적인 관련이 없다. 프로토타입의 `constructor` 프로퍼티는 모든 프로토타입이 가지고 있는 프로퍼티로, 생성자 함수를 가리킨다.

`constructor`는 생성자 함수와 유사하지만 몇 가지 차이점이 있다.

1. `constructor`는 클래스 내 한 개 이상 존재할 수 없다.
2. `constructor`를 생략하면 빈 `constructor`가 암묵적으로 정의된다.

   인스턴스를 초기화하려면 `constructor`를 생략하면 안 된다.

3. `constructor`는 별도의 반환문을 갖지 않아야 한다.

   생성자 함수와 동일하게 암묵적으로 `this`, 즉 인스턴스를 반환하기 때문이다. 다른 객체를 명시적으로 반환하면 `return` 문에 명시한 객체가 반환된다. 하지만 원시값을 반환하면 원시값 반환은 무시되고 `this`가 반환된다.

### 프로토타입 메서드

클래스 몸체에 정의한 메서드는 기본적으로 프로토타입 메서드가 된다.

```js
class Person {
  // 생성자
  constructor(name) {
    // 인스턴스 생성 및 초기화
    this.name = name;
  }

  // 프로토타입 메서드
  sayHi() {
    console.log(`Hi! My name is ${this.name}`);
  }
}

const me = new Person("Lee");
me.sayHi(); // Hi! My name is Lee
```

### 정적 메서드

`static` 키워드를 붙이면 정적 메서드가 된다.

```js
class Person {
  // 생성자
  constructor(name) {
    // 인스턴스 생성 및 초기화
    this.name = name;
  }

  // 정적 메서드
  static sayHi() {
    console.log("Hi!");
  }
}
```

💡정적 메서드는 인스턴스로 호출할 수 없다.

### 정적 메서드와 프로토타입 메서드의 차이

1. 자신이 속해 있는 프로토타입 체인이 다르다.
2. 정적 메서드는 클래스로 호출하지만 프로토타입 메서드는 인스턴스로 호출한다.
3. 정적 메서드는 인스턴스 프로퍼티를 참조할 수 없지만 프로토타입 메서드는 가능하다.

### 클래스에서 정의한 메서드의 특징

1. `function` 키워드를 생략한 메서드 축약 표현을 사용한다.
2. 객체 리터럴과는 다르게 클래스에 메서드를 정의할 때는 콤마가 필요 없다.
3. 암묵적으로 strict mode로 실행된다.
4. `for...in` 문이나 `Object.keys` 메서드 등으로 열거할 수 없다. (`[[Enumerable]]` 값이 `false`다.)
5. 내부 메서드 `[[Constructor]]`를 갖지 않는 non-constructor다. 따라서 `new` 연산자와 함께 호출할 수 없다.
