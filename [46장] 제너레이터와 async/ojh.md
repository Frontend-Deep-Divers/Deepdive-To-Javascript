# 46.1 제너레이터란?

---

- ES6 에 도입된 제너레이터는 코드 블록의 실행을 일시 중지했다가 필요한 시점에 재개할 수 있는 특이한 함수다.
- 제너레이터와 일반 함수의 차이는 다음과 같다.
  1. 제너레이터 함수는 함수 호출자에게 함수 실행의 제어권을 양도할 수 있다.
  2. 제너레이터 함수는 함수 호출자와 함수의 상태를 주고 받을 수 있다.
  3. 제너레이터 함수를 호출하면 제너레이터 객체를 반환한다.
  ![image.png](attachment:b3d2dcaf-06b7-4ca3-afe3-78a5de912615:image.png)

# 46.2 제너레이터 함수의 정의

---

- **function\* 키워드로 선언한다.**
- **그리고 하나 이상의 yield 표현식을 포함한다.**
  ![image.png](attachment:d3f80135-ba0b-411a-b0ea-48fb55d55321:image.png)
- - 의 위치는 function 키워드와 함수 이름 사이라면 어디든지 상관없다. 다만 일관성 유지를 위해 function 키워드 바로 뒤에 붙이는 것을 권장함.

    ![image.png](attachment:11a138e5-d1e1-4e81-9178-03cf5d7e12a6:image.png)
- 화살표 함수로는 정의할 수 없고, new 연산자를 사용해 생성자 함수로 호출할 수 없다.
  ![image.png](attachment:f803c6c8-a927-47b4-bbcc-e7a3a6abc0b7:image.png)

# 46.3 제너레이터 객체

---

- **제너레이터 함수를 호출하면 일반 함수처럼 함수 코드 블록을 실행하는 것이 아니라 제너레이터 객체를 생성해 반환한다. 제너레이터 함수가 반환한 제너레이터 객체는 이터러블이면서 동시에 이터레이터이다.**
  ![image.png](attachment:f0b4ff3c-269a-4aff-bc49-3eaa10953d78:image.png)
- 제너레이트 객체는 next 메서드를 갖는 이터레이터이지만 이터레이터에는 없는 return, throw 메서드를 갖는다. 제너레이터 객체의 세 개의 메서드를 호출하면 다음과 같이 동작한다.
  ![image.png](attachment:0e2bb6f1-0e06-4408-abf1-86e139c96c8c:image.png)

# 46.4 제너레이터의 일시 중지와 재개

---

- 제너레이터는 yield 키워드와 next 메서드를 통해 실행을 중지했다가 필요한 시점에 다시 재개할 수 있다. 일반 함수는 호출 이후 제어권을 함수가 독점하지만 제너레이터는 함수 호출자에게 제어권을 양도하여 필요한 시점에 함수 실행을 재개할 수 있다.
- next 메서드를 호출하면 제너레이터 함수의 코드 블록을 실행한다. → 단, 일반 함수처럼 한 번에 코드 블록의 모든 코드를 일괄 실행하는 것이 아니라 yield 표현식까지만 실행한다.
- ❓ **yield 키워드는 제너레이터 함수의 실행을 일시 중지시키거나 yield 키워드 뒤에 오는 표현식의 평가 결과를 제너레이터 함수 호출자에게 반환한다.**

  ![image.png](attachment:587820a1-6c69-41c7-808e-2579360d20fd:image.png)

- 제너레이터 객체의 next 메서드를 호출하면 yield 표현식까지 실행되고 일시 중지 된다. → 이 때 함수의 제어권이 호출자로 양도된다.
- 이터레이터 리절트 객체에 value 에는 yield 값 done 프로퍼티에는 제너레이터 함수가 끝까지 실행되었는지 불리언 값이 할당된다.
  ![image.png](attachment:c4dbdca0-b6f1-4dc5-b623-68109aafb352:image.png)
- 이처럼 제너레이터 함수는 next 메서드와 yield 표현식을 통해 함수 호출자와 함수의 상태를 주고 받을 수 있다.
- next 메서드를 통해 yield 표현식까지 함수를 실행시켜 제너레이터 객체가 관리하는 상태를 꺼내올 수 있고, next 메서드에 인수를 전달해서 제너레이터 객체에 상태를 밀어 넣을 수 있다.
- 이걸 통해 비동기 처리를 동기 처리처럼 구현할 수 있다.

# 46.5 제너레이터의 활용

---

### 1️⃣ 이터러블의 구현

- 이터러블로 무한 수열 구현
  ![image.png](attachment:6d1e13fe-8ad0-41c4-ace2-605462d2f871:image.png)
- 제너레이터 함수를 사용하면 이터레이션 프로토콜을 준수해 이터러블을 생성하는 방식보다 간단히 이터러블 구현 가능하다.
  ![image.png](attachment:21d67d94-51d0-4ef7-aa98-cde7197d26d2:image.png)

### 2️⃣ 비동기 처리

- 제너레이터 함수의 특징을 사용해 프로미스의 후속처리 메서드 없이 비동기 처리 결과를 반환하도록 구현할 수 있다.
  ![image.png](attachment:32b2de40-a789-4f33-885a-704f18cccc3f:image.png)

# 46.6 async / await

---

- 제너레이터를 사용해서 비동기 처리를 동기 처리처럼 구현하도록 구현했지만 코드가 무척이나 장황해지고 가독성도 나빠졌다. 이를 위해 **ES8 (ECMAScript 2017) 에서 제너레이터보다 간단하고 가독성이 좋은 async / await 가 도입되었다.**
- 프로미스 기반으로 동작한다.
- 동기 처리처럼 프로미스를 사용할 수 있다.
  ![image.png](attachment:2628d8ee-65ef-4d11-85f4-35b332cfaf47:image.png)

### 1️⃣ async 함수

- await 는 반드시 async 함수 내부에서 사용해야 한다.
- 🌟 **비동기 함수는 async 키워드를 통해 정의하며 언제나 프로미스를 반환한다.**
- 명시적으로 반환하지 않더라도 암묵적으로 반환값을 resolve 하는 프로미스를 반환한다.
  ![image.png](attachment:198d2d09-f6e3-4923-9b39-7640e763843c:image.png)

### 2️⃣ await

- 프로미스가 settled 상태가 되면 프러미스가 resolve 한 처리 결과를 반환한다.
- ❗await 키워드는 반드시 프로미스 앞에서 사용해야 한다.
  ![image.png](attachment:080d0453-25a5-4331-9824-654e0836c6b0:image.png)
- settled 상태가 되면 프로미스가 resolve 한 결과를 res 변수에 할당한다.
- await 키워드는 다음 실행을 일시 중지 했다가 프로미스가 settled 상태가 되면 다시 재개한다.
  ![image.png](attachment:889cb310-e521-456c-a993-82a62790c561:image.png)
- 비동기 처리하고 싶으면 다음과 같이 사용하면 된다.
  ![image.png](attachment:51907733-18a3-40b2-aab2-5c2214b8cf46:image.png)
- 물론 처리 순서가 보장되어야 하면 순차적으로 처리해야 한다.
  ![image.png](attachment:a8babb84-a033-475e-890e-1a1746c71fda:image.png)

### 3. 에러 처리

- 비동기 처리를 위한 콜백 패턴의 가장 심각한 단점은 에러 처리가 곤란하다는 것이다.
- 에러는 호출자 방향으로 전파하는데, 비동기 함수의 콜백 함수를 호출한 것은 비동기 함수가 아니기 때문에 try - catch 문을 사용해 에러를 캐치할 수 없다.
  ![image.png](attachment:1ff8042e-aee5-47b3-ba5a-da6422c787ae:image.png)
- 하지만 async / await 를 사용하면 프로미스를 반환하는 비동기 함수를 명시적으로 호출할 수 있기 때문에 호출자가 명확하다.
  ![image.png](attachment:7cd730b5-2ce1-4c5a-87e6-7a9725e2cfc8:image.png)
- 모든 에러를 캐치할 수 있다.
- **만약 해당 함수에서 에러 처리를 하지 않으면 async 함수가 발생한 에러를 reject하는 프로미스가 반환되어 Promise.prototype.catch 후속 처리 메서드를 사용해 캐치할 수도 있다.**
  ![image.png](attachment:c2e9afc1-5d63-4972-b678-bf2a827c8ff6:image.png)
