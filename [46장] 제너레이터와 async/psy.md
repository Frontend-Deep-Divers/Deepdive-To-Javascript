## 제너레이터

코드 블록의 실행을 일시 중지했다가 필요한 시점에 재개할 수 있는 특수한 함수

1. 함수의 실행 제어권을 함수 호출자에게 양도함
2. 함수 호출자와 함수의 상태를 주고받을 수 있음
3. 제너레이터 함수를 호출하면 제너레이터 객체를 반환함
    1. 제너레이터 객체는 이터러블이면서 동시에 이터레이터

### 정의

function* 키워드로 선언하고 내부에 yield 표현식을 하나 이상 포함해야 함

### 제너레이터 객체

제너레이터 객체는 이터러블이면서 이터레이터

next(), return(), throw() 세 개의 메소드를 가짐

- next()
    - 제너레이터 함수의 yield 표현식까지 코드 블록을 실행하고 yield된 값을 value 프로퍼티 값으로, false를 done 프로퍼티 값으로 갖는 이터레이터 리절트 객체를 반환
    - 마지막 yield 까지 반환했으면 undefined, true 객체를 반환
    - 매개변수를 전달하면 yield 표현식을 할당받는 변수에 할당함
- return()
    - 매개변수로 전달한 값을 value 프로퍼티 값으로, true를 done 프로퍼티 값으로 갖는 이터레이터 리절트 객체를 반환
- throw()
    - 매개변수로 전달한 Error를 발생시키고( 제너레이터 함수 내에서 ), undefined를 value 프로퍼티 값으로, true를 done 프로퍼티 값으로 갖는 이터레이터 리절트 객체를 반환

### 활용

1. 이터러블을 간단히 구현할 수 있음
2. 비동기 처리를 동기 처리처럼 구현할 수 있음
    1. 제너레이터 실행기
    2. 코드가 가독성이 나빠짐

## async/await

제너레이터를 사용해서 비동기 처리를 동기 처리처럼 동작하도록 구현했지만 가독성이 나빠짐

ES8부터 async/await 도입

### async 함수

항상 프로미스를 반환

명시적으로 프로미스를 반환하지 않으면 암묵적으로 반환값을 resolve하는 프로미스를 반환

### await 키워드

async 함수 내에서 프로미스 앞에서 사용

프로미스가 settled 상태가 될 때까지 함수의 실행을 멈췄다가 프로미스가 resolve한 처리 결과를 반환하고 다시 함수를 실행

### 에러 처리

try catch 문으로 에러 처리 가능
